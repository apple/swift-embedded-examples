// Generated by svd2swift.

import MMIO

/// Inter-integrated circuit
@RegisterBlock
public struct I2C1 {
    /// Control register 1
    @RegisterBlock(offset: 0x0)
    public var cr1: Register<CR1>

    /// Control register 2
    @RegisterBlock(offset: 0x4)
    public var cr2: Register<CR2>

    /// Own address register 1
    @RegisterBlock(offset: 0x8)
    public var oar1: Register<OAR1>

    /// Own address register 2
    @RegisterBlock(offset: 0xc)
    public var oar2: Register<OAR2>

    /// Timing register
    @RegisterBlock(offset: 0x10)
    public var timingr: Register<TIMINGR>

    /// Status register 1
    @RegisterBlock(offset: 0x14)
    public var timeoutr: Register<TIMEOUTR>

    /// Interrupt and Status register
    @RegisterBlock(offset: 0x18)
    public var isr: Register<ISR>

    /// Interrupt clear register
    @RegisterBlock(offset: 0x1c)
    public var icr: Register<ICR>

    /// PEC register
    @RegisterBlock(offset: 0x20)
    public var pecr: Register<PECR>

    /// Receive data register
    @RegisterBlock(offset: 0x24)
    public var rxdr: Register<RXDR>

    /// Transmit data register
    @RegisterBlock(offset: 0x28)
    public var txdr: Register<TXDR>
}

extension I2C1 {
    /// Control register 1
    @Register(bitWidth: 32)
    public struct CR1 {
        /// Peripheral enable
        @ReadWrite(bits: 0..<1, as: PEValues.self)
        public var pe: PE

        /// TX Interrupt enable
        @ReadWrite(bits: 1..<2, as: TXIEValues.self)
        public var txie: TXIE

        /// RX Interrupt enable
        @ReadWrite(bits: 2..<3, as: RXIEValues.self)
        public var rxie: RXIE

        /// Address match interrupt enable (slave only)
        @ReadWrite(bits: 3..<4, as: ADDRIEValues.self)
        public var addrie: ADDRIE

        /// Not acknowledge received interrupt enable
        @ReadWrite(bits: 4..<5, as: NACKIEValues.self)
        public var nackie: NACKIE

        /// STOP detection Interrupt enable
        @ReadWrite(bits: 5..<6, as: STOPIEValues.self)
        public var stopie: STOPIE

        /// Transfer Complete interrupt enable
        @ReadWrite(bits: 6..<7, as: TCIEValues.self)
        public var tcie: TCIE

        /// Error interrupts enable
        @ReadWrite(bits: 7..<8, as: ERRIEValues.self)
        public var errie: ERRIE

        /// Digital noise filter
        @ReadWrite(bits: 8..<12, as: DNFValues.self)
        public var dnf: DNF

        /// Analog noise filter OFF
        @ReadWrite(bits: 12..<13, as: ANFOFFValues.self)
        public var anfoff: ANFOFF

        /// DMA transmission requests enable
        @ReadWrite(bits: 14..<15, as: TXDMAENValues.self)
        public var txdmaen: TXDMAEN

        /// DMA reception requests enable
        @ReadWrite(bits: 15..<16, as: RXDMAENValues.self)
        public var rxdmaen: RXDMAEN

        /// Slave byte control
        @ReadWrite(bits: 16..<17, as: SBCValues.self)
        public var sbc: SBC

        /// Clock stretching disable
        @ReadWrite(bits: 17..<18, as: NOSTRETCHValues.self)
        public var nostretch: NOSTRETCH

        /// Wakeup from STOP enable
        @ReadWrite(bits: 18..<19, as: WUPENValues.self)
        public var wupen: WUPEN

        /// General call enable
        @ReadWrite(bits: 19..<20, as: GCENValues.self)
        public var gcen: GCEN

        /// SMBus Host address enable
        @ReadWrite(bits: 20..<21, as: SMBHENValues.self)
        public var smbhen: SMBHEN

        /// SMBus Device Default address enable
        @ReadWrite(bits: 21..<22, as: SMBDENValues.self)
        public var smbden: SMBDEN

        /// SMBUS alert enable
        @ReadWrite(bits: 22..<23, as: ALERTENValues.self)
        public var alerten: ALERTEN

        /// PEC enable
        @ReadWrite(bits: 23..<24, as: PECENValues.self)
        public var pecen: PECEN
    }

    /// Control register 2
    @Register(bitWidth: 32)
    public struct CR2 {
        /// Packet error checking byte
        @ReadWrite(bits: 26..<27)
        public var pecbyte: PECBYTE

        /// Automatic end mode (master mode)
        @ReadWrite(bits: 25..<26, as: AUTOENDValues.self)
        public var autoend: AUTOEND

        /// NBYTES reload mode
        @ReadWrite(bits: 24..<25, as: RELOADValues.self)
        public var reload: RELOAD

        /// Number of bytes
        @ReadWrite(bits: 16..<24)
        public var nbytes: NBYTES

        /// NACK generation (slave mode)
        @ReadWrite(bits: 15..<16)
        public var nack: NACK

        /// Stop generation (master mode)
        @ReadWrite(bits: 14..<15)
        public var stop: STOP

        /// Start generation
        @ReadWrite(bits: 13..<14)
        public var start: START

        /// 10-bit address header only read direction (master receiver mode)
        @ReadWrite(bits: 12..<13, as: HEAD10RValues.self)
        public var head10r: HEAD10R

        /// 10-bit addressing mode (master mode)
        @ReadWrite(bits: 11..<12, as: ADD10Values.self)
        public var add10: ADD10

        /// Transfer direction (master mode)
        @ReadWrite(bits: 10..<11, as: RD_WRNValues.self)
        public var rd_wrn: RD_WRN

        /// Slave address bit (master mode)
        @ReadWrite(bits: 0..<10)
        public var sadd: SADD
    }

    /// Own address register 1
    @Register(bitWidth: 32)
    public struct OAR1 {
        /// Interface address
        @ReadWrite(bits: 0..<10)
        public var oa1: OA1

        /// Own Address 1 10-bit mode
        @ReadWrite(bits: 10..<11, as: OA1MODEValues.self)
        public var oa1mode: OA1MODE

        /// Own Address 1 enable
        @ReadWrite(bits: 15..<16, as: OA1ENValues.self)
        public var oa1en: OA1EN
    }

    /// Own address register 2
    @Register(bitWidth: 32)
    public struct OAR2 {
        /// Interface address
        @ReadWrite(bits: 1..<8)
        public var oa2: OA2

        /// Own Address 2 masks
        @ReadWrite(bits: 8..<11, as: OA2MSKValues.self)
        public var oa2msk: OA2MSK

        /// Own Address 2 enable
        @ReadWrite(bits: 15..<16, as: OA2ENValues.self)
        public var oa2en: OA2EN
    }

    /// Timing register
    @Register(bitWidth: 32)
    public struct TIMINGR {
        /// SCL low period (master mode)
        @ReadWrite(bits: 0..<8)
        public var scll: SCLL

        /// SCL high period (master mode)
        @ReadWrite(bits: 8..<16)
        public var sclh: SCLH

        /// Data hold time
        @ReadWrite(bits: 16..<20)
        public var sdadel: SDADEL

        /// Data setup time
        @ReadWrite(bits: 20..<24)
        public var scldel: SCLDEL

        /// Timing prescaler
        @ReadWrite(bits: 28..<32)
        public var presc: PRESC
    }

    /// Status register 1
    @Register(bitWidth: 32)
    public struct TIMEOUTR {
        /// Bus timeout A
        @ReadWrite(bits: 0..<12)
        public var timeouta: TIMEOUTA

        /// Idle clock timeout detection
        @ReadWrite(bits: 12..<13, as: TIDLEValues.self)
        public var tidle: TIDLE

        /// Clock timeout enable
        @ReadWrite(bits: 15..<16, as: TIMOUTENValues.self)
        public var timouten: TIMOUTEN

        /// Bus timeout B
        @ReadWrite(bits: 16..<28)
        public var timeoutb: TIMEOUTB

        /// Extended clock timeout enable
        @ReadWrite(bits: 31..<32, as: TEXTENValues.self)
        public var texten: TEXTEN
    }

    /// Interrupt and Status register
    @Register(bitWidth: 32)
    public struct ISR {
        /// Address match code (Slave mode)
        @ReadOnly(bits: 17..<24)
        public var addcode: ADDCODE

        /// Transfer direction (Slave mode)
        @ReadOnly(bits: 16..<17)
        public var dir: DIR

        /// Bus busy
        @ReadOnly(bits: 15..<16)
        public var busy: BUSY

        /// SMBus alert
        @ReadOnly(bits: 13..<14)
        public var alert: ALERT

        /// Timeout or t_low detection flag
        @ReadOnly(bits: 12..<13)
        public var timeout: TIMEOUT

        /// PEC Error in reception
        @ReadOnly(bits: 11..<12)
        public var pecerr: PECERR

        /// Overrun/Underrun (slave mode)
        @ReadOnly(bits: 10..<11)
        public var ovr: OVR

        /// Arbitration lost
        @ReadOnly(bits: 9..<10)
        public var arlo: ARLO

        /// Bus error
        @ReadOnly(bits: 8..<9)
        public var berr: BERR

        /// Transfer Complete Reload
        @ReadOnly(bits: 7..<8)
        public var tcr: TCR

        /// Transfer Complete (master mode)
        @ReadOnly(bits: 6..<7)
        public var tc: TC

        /// Stop detection flag
        @ReadOnly(bits: 5..<6)
        public var stopf: STOPF

        /// Not acknowledge received flag
        @ReadOnly(bits: 4..<5)
        public var nackf: NACKF

        /// Address matched (slave mode)
        @ReadOnly(bits: 3..<4)
        public var addr: ADDR

        /// Receive data register not empty (receivers)
        @ReadOnly(bits: 2..<3)
        public var rxne: RXNE

        /// Transmit interrupt status (transmitters)
        @ReadWrite(bits: 1..<2)
        public var txis: TXIS

        /// Transmit data register empty (transmitters)
        @ReadWrite(bits: 0..<1)
        public var txe: TXE
    }

    /// Interrupt clear register
    @Register(bitWidth: 32)
    public struct ICR {
        /// Alert flag clear
        @WriteOnly(bits: 13..<14)
        public var alertcf: ALERTCF

        /// Timeout detection flag clear
        @WriteOnly(bits: 12..<13)
        public var timoutcf: TIMOUTCF

        /// PEC Error flag clear
        @WriteOnly(bits: 11..<12)
        public var peccf: PECCF

        /// Overrun/Underrun flag clear
        @WriteOnly(bits: 10..<11)
        public var ovrcf: OVRCF

        /// Arbitration lost flag clear
        @WriteOnly(bits: 9..<10)
        public var arlocf: ARLOCF

        /// Bus error flag clear
        @WriteOnly(bits: 8..<9)
        public var berrcf: BERRCF

        /// Stop detection flag clear
        @WriteOnly(bits: 5..<6)
        public var stopcf: STOPCF

        /// Not Acknowledge flag clear
        @WriteOnly(bits: 4..<5)
        public var nackcf: NACKCF

        /// Address Matched flag clear
        @WriteOnly(bits: 3..<4)
        public var addrcf: ADDRCF
    }

    /// PEC register
    @Register(bitWidth: 32)
    public struct PECR {
        /// Packet error checking register
        @ReadOnly(bits: 0..<8)
        public var pec: PEC
    }

    /// Receive data register
    @Register(bitWidth: 32)
    public struct RXDR {
        /// 8-bit receive data
        @ReadOnly(bits: 0..<8)
        public var rxdata: RXDATA
    }

    /// Transmit data register
    @Register(bitWidth: 32)
    public struct TXDR {
        /// 8-bit transmit data
        @ReadWrite(bits: 0..<8)
        public var txdata: TXDATA
    }
}

extension I2C1.CR1 {
    public struct PEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Peripheral disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Peripheral enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct TXIEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Transmit (TXIS) interrupt disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Transmit (TXIS) interrupt enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct RXIEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Receive (RXNE) interrupt disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Receive (RXNE) interrupt enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct ADDRIEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Address match (ADDR) interrupts disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Address match (ADDR) interrupts enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct NACKIEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Not acknowledge (NACKF) received interrupts disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Not acknowledge (NACKF) received interrupts enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct STOPIEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Stop detection (STOPF) interrupt disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Stop detection (STOPF) interrupt enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct TCIEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Transfer Complete interrupt disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Transfer Complete interrupt enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct ERRIEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Error detection interrupts disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Error detection interrupts enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct DNFValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 4

        /// Digital filter disabled
        public static let NoFilter = Self(rawValue: 0x0)

        /// Digital filter enabled and filtering capability up to 1 tI2CCLK
        public static let Filter1 = Self(rawValue: 0x1)

        /// Digital filter enabled and filtering capability up to 2 tI2CCLK
        public static let Filter2 = Self(rawValue: 0x2)

        /// Digital filter enabled and filtering capability up to 3 tI2CCLK
        public static let Filter3 = Self(rawValue: 0x3)

        /// Digital filter enabled and filtering capability up to 4 tI2CCLK
        public static let Filter4 = Self(rawValue: 0x4)

        /// Digital filter enabled and filtering capability up to 5 tI2CCLK
        public static let Filter5 = Self(rawValue: 0x5)

        /// Digital filter enabled and filtering capability up to 6 tI2CCLK
        public static let Filter6 = Self(rawValue: 0x6)

        /// Digital filter enabled and filtering capability up to 7 tI2CCLK
        public static let Filter7 = Self(rawValue: 0x7)

        /// Digital filter enabled and filtering capability up to 8 tI2CCLK
        public static let Filter8 = Self(rawValue: 0x8)

        /// Digital filter enabled and filtering capability up to 9 tI2CCLK
        public static let Filter9 = Self(rawValue: 0x9)

        /// Digital filter enabled and filtering capability up to 10 tI2CCLK
        public static let Filter10 = Self(rawValue: 0xa)

        /// Digital filter enabled and filtering capability up to 11 tI2CCLK
        public static let Filter11 = Self(rawValue: 0xb)

        /// Digital filter enabled and filtering capability up to 12 tI2CCLK
        public static let Filter12 = Self(rawValue: 0xc)

        /// Digital filter enabled and filtering capability up to 13 tI2CCLK
        public static let Filter13 = Self(rawValue: 0xd)

        /// Digital filter enabled and filtering capability up to 14 tI2CCLK
        public static let Filter14 = Self(rawValue: 0xe)

        /// Digital filter enabled and filtering capability up to 15 tI2CCLK
        public static let Filter15 = Self(rawValue: 0xf)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct ANFOFFValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Analog noise filter enabled
        public static let Enabled = Self(rawValue: 0x0)

        /// Analog noise filter disabled
        public static let Disabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct TXDMAENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// DMA mode disabled for transmission
        public static let Disabled = Self(rawValue: 0x0)

        /// DMA mode enabled for transmission
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct RXDMAENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// DMA mode disabled for reception
        public static let Disabled = Self(rawValue: 0x0)

        /// DMA mode enabled for reception
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct SBCValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Slave byte control disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Slave byte control enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct NOSTRETCHValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Clock stretching enabled
        public static let Enabled = Self(rawValue: 0x0)

        /// Clock stretching disabled
        public static let Disabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct WUPENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Wakeup from Stop mode disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Wakeup from Stop mode enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct GCENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// General call disabled. Address 0b00000000 is NACKed
        public static let Disabled = Self(rawValue: 0x0)

        /// General call enabled. Address 0b00000000 is ACKed
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct SMBHENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Host address disabled. Address 0b0001000x is NACKed
        public static let Disabled = Self(rawValue: 0x0)

        /// Host address enabled. Address 0b0001000x is ACKed
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct SMBDENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Device default address disabled. Address 0b1100001x is NACKed
        public static let Disabled = Self(rawValue: 0x0)

        /// Device default address enabled. Address 0b1100001x is ACKed
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct ALERTENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// In device mode (SMBHEN=Disabled) Releases SMBA pin high and Alert Response Address Header disabled (0001100x) followed by NACK. In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) not supported
        public static let Disabled = Self(rawValue: 0x0)

        /// In device mode (SMBHEN=Disabled) Drives SMBA pin low and Alert Response Address Header enabled (0001100x) followed by ACK.In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) supported
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR1 {
    public struct PECENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// PEC calculation disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// PEC calculation enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR2 {
    public struct AUTOENDValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low
        public static let Software = Self(rawValue: 0x0)

        /// Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred
        public static let Automatic = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR2 {
    public struct RELOADValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// The transfer is completed after the NBYTES data transfer (STOP or RESTART will follow)
        public static let Completed = Self(rawValue: 0x0)

        /// The transfer is not completed after the NBYTES data transfer (NBYTES will be reloaded)
        public static let NotCompleted = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR2 {
    public struct HEAD10RValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// The master sends the complete 10 bit slave address read sequence
        public static let Complete = Self(rawValue: 0x0)

        /// The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction
        public static let Partial = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR2 {
    public struct ADD10Values: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// The master operates in 7-bit addressing mode
        public static let Bit7 = Self(rawValue: 0x0)

        /// The master operates in 10-bit addressing mode
        public static let Bit10 = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.CR2 {
    public struct RD_WRNValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Master requests a write transfer
        public static let Write = Self(rawValue: 0x0)

        /// Master requests a read transfer
        public static let Read = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.OAR1 {
    public struct OA1MODEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Own address 1 is a 7-bit address
        public static let Bit7 = Self(rawValue: 0x0)

        /// Own address 1 is a 10-bit address
        public static let Bit10 = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.OAR1 {
    public struct OA1ENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Own address 1 disabled. The received slave address OA1 is NACKed
        public static let Disabled = Self(rawValue: 0x0)

        /// Own address 1 enabled. The received slave address OA1 is ACKed
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.OAR2 {
    public struct OA2MSKValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 3

        /// No mask
        public static let NoMask = Self(rawValue: 0x0)

        /// OA2[1] is masked and don’t care. Only OA2[7:2] are compared
        public static let Mask1 = Self(rawValue: 0x1)

        /// OA2[2:1] are masked and don’t care. Only OA2[7:3] are compared
        public static let Mask2 = Self(rawValue: 0x2)

        /// OA2[3:1] are masked and don’t care. Only OA2[7:4] are compared
        public static let Mask3 = Self(rawValue: 0x3)

        /// OA2[4:1] are masked and don’t care. Only OA2[7:5] are compared
        public static let Mask4 = Self(rawValue: 0x4)

        /// OA2[5:1] are masked and don’t care. Only OA2[7:6] are compared
        public static let Mask5 = Self(rawValue: 0x5)

        /// OA2[6:1] are masked and don’t care. Only OA2[7] is compared.
        public static let Mask6 = Self(rawValue: 0x6)

        /// OA2[7:1] are masked and don’t care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged
        public static let Mask7 = Self(rawValue: 0x7)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.OAR2 {
    public struct OA2ENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Own address 2 disabled. The received slave address OA2 is NACKed
        public static let Disabled = Self(rawValue: 0x0)

        /// Own address 2 enabled. The received slave address OA2 is ACKed
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.TIMEOUTR {
    public struct TIDLEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// TIMEOUTA is used to detect SCL low timeout
        public static let Disabled = Self(rawValue: 0x0)

        /// TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.TIMEOUTR {
    public struct TIMOUTENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// SCL timeout detection is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// SCL timeout detection is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2C1.TIMEOUTR {
    public struct TEXTENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Extended clock timeout detection is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Extended clock timeout detection is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
