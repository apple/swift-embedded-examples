// Generated by svd2swift.

import MMIO

/// FLASH
@RegisterBlock
public struct FLASH {
    /// Flash access control register
    @RegisterBlock(offset: 0x0)
    public var acr: Register<ACR>

    /// Flash key register
    @RegisterBlock(offset: 0x4)
    public var keyr: Register<KEYR>

    /// Flash option key register
    @RegisterBlock(offset: 0x8)
    public var optkeyr: Register<OPTKEYR>

    /// Status register
    @RegisterBlock(offset: 0xc)
    public var sr: Register<SR>

    /// Control register
    @RegisterBlock(offset: 0x10)
    public var cr: Register<CR>

    /// Flash option control register
    @RegisterBlock(offset: 0x14)
    public var optcr: Register<OPTCR>

    /// Flash option control register 1
    @RegisterBlock(offset: 0x18)
    public var optcr1: Register<OPTCR1>
}

extension FLASH {
    /// Flash access control register
    @Register(bitWidth: 32)
    public struct ACR {
        /// Latency
        @ReadWrite(bits: 0..<4, as: LATENCYValues.self)
        public var latency: LATENCY

        /// Prefetch enable
        @ReadWrite(bits: 8..<9, as: PRFTENValues.self)
        public var prften: PRFTEN

        /// ART Accelerator Enable
        @ReadWrite(bits: 9..<10, as: ARTENValues.self)
        public var arten: ARTEN

        /// ART Accelerator reset
        @ReadWrite(bits: 11..<12, as: ARTRSTValues.self)
        public var artrst: ARTRST
    }

    /// Flash key register
    @Register(bitWidth: 32)
    public struct KEYR {
        /// FPEC key
        @WriteOnly(bits: 0..<32)
        public var key: KEY
    }

    /// Flash option key register
    @Register(bitWidth: 32)
    public struct OPTKEYR {
        /// Option byte key
        @WriteOnly(bits: 0..<32)
        public var optkeyr_field: OPTKEYR_FIELD
    }

    /// Status register
    @Register(bitWidth: 32)
    public struct SR {
        /// End of operation
        @ReadWrite(bits: 0..<1)
        public var eop: EOP

        /// Operation error
        @ReadWrite(bits: 1..<2)
        public var operr: OPERR

        /// Write protection error
        @ReadWrite(bits: 4..<5)
        public var wrperr: WRPERR

        /// Programming alignment error
        @ReadWrite(bits: 5..<6)
        public var pgaerr: PGAERR

        /// Programming parallelism error
        @ReadWrite(bits: 6..<7)
        public var pgperr: PGPERR

        /// Programming sequence error
        @ReadWrite(bits: 7..<8)
        public var erserr: ERSERR

        /// Busy
        @ReadOnly(bits: 16..<17)
        public var bsy: BSY
    }

    /// Control register
    @Register(bitWidth: 32)
    public struct CR {
        /// Programming
        @ReadWrite(bits: 0..<1, as: PGValues.self)
        public var pg: PG

        /// Sector Erase
        @ReadWrite(bits: 1..<2, as: SERValues.self)
        public var ser: SER

        /// Mass Erase of sectors 0 to 11
        @ReadWrite(bits: 2..<3, as: MERValues.self)
        public var mer: MER

        /// Sector number
        @ReadWrite(bits: 3..<7)
        public var snb: SNB

        /// Program size
        @ReadWrite(bits: 8..<10, as: PSIZEValues.self)
        public var psize: PSIZE

        /// Start
        @ReadWrite(bits: 16..<17, as: STRTValues.self)
        public var strt: STRT

        /// End of operation interrupt enable
        @ReadWrite(bits: 24..<25, as: EOPIEValues.self)
        public var eopie: EOPIE

        /// Error interrupt enable
        @ReadWrite(bits: 25..<26, as: ERRIEValues.self)
        public var errie: ERRIE

        /// Lock
        @ReadWrite(bits: 31..<32, as: LOCKValues.self)
        public var lock: LOCK
    }

    /// Flash option control register
    @Register(bitWidth: 32)
    public struct OPTCR {
        /// Option lock
        @ReadWrite(bits: 0..<1)
        public var optlock: OPTLOCK

        /// Option start
        @ReadWrite(bits: 1..<2)
        public var optstrt: OPTSTRT

        /// BOR reset Level
        @ReadWrite(bits: 2..<4)
        public var bor_lev: BOR_LEV

        /// User option bytes
        @ReadWrite(bits: 4..<5)
        public var wwdg_sw: WWDG_SW

        /// User option bytes
        @ReadWrite(bits: 5..<6)
        public var iwdg_sw: IWDG_SW

        /// User option bytes
        @ReadWrite(bits: 6..<7)
        public var nrst_stop: nRST_STOP

        /// User option bytes
        @ReadWrite(bits: 7..<8)
        public var nrst_stdby: nRST_STDBY

        /// Read protect
        @ReadWrite(bits: 8..<16)
        public var rdp: RDP

        /// Not write protect
        @ReadWrite(bits: 16..<24)
        public var nwrp: nWRP

        /// Independent watchdog counter freeze in standby mode
        @ReadWrite(bits: 30..<31)
        public var iwdg_stdby: IWDG_STDBY

        /// Independent watchdog counter freeze in Stop mode
        @ReadWrite(bits: 31..<32)
        public var iwdg_stop: IWDG_STOP
    }

    /// Flash option control register 1
    @Register(bitWidth: 32)
    public struct OPTCR1 {
        /// Boot base address when Boot pin =0
        @ReadWrite(bits: 0..<16)
        public var boot_add0: BOOT_ADD0

        /// Boot base address when Boot pin =1
        @ReadWrite(bits: 16..<32)
        public var boot_add1: BOOT_ADD1
    }
}

extension FLASH.ACR {
    public struct LATENCYValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 4

        /// 0 wait states
        public static let WS0 = Self(rawValue: 0x0)

        /// 1 wait states
        public static let WS1 = Self(rawValue: 0x1)

        /// 2 wait states
        public static let WS2 = Self(rawValue: 0x2)

        /// 3 wait states
        public static let WS3 = Self(rawValue: 0x3)

        /// 4 wait states
        public static let WS4 = Self(rawValue: 0x4)

        /// 5 wait states
        public static let WS5 = Self(rawValue: 0x5)

        /// 6 wait states
        public static let WS6 = Self(rawValue: 0x6)

        /// 7 wait states
        public static let WS7 = Self(rawValue: 0x7)

        /// 8 wait states
        public static let WS8 = Self(rawValue: 0x8)

        /// 9 wait states
        public static let WS9 = Self(rawValue: 0x9)

        /// 10 wait states
        public static let WS10 = Self(rawValue: 0xa)

        /// 11 wait states
        public static let WS11 = Self(rawValue: 0xb)

        /// 12 wait states
        public static let WS12 = Self(rawValue: 0xc)

        /// 13 wait states
        public static let WS13 = Self(rawValue: 0xd)

        /// 14 wait states
        public static let WS14 = Self(rawValue: 0xe)

        /// 15 wait states
        public static let WS15 = Self(rawValue: 0xf)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.ACR {
    public struct PRFTENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Prefetch is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Prefetch is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.ACR {
    public struct ARTENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// ART Accelerator is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// ART Accelerator is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.ACR {
    public struct ARTRSTValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Accelerator is not reset
        public static let NotReset = Self(rawValue: 0x0)

        /// Accelerator is reset
        public static let Reset = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    public struct PGValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Flash programming activated
        public static let Program = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    public struct SERValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Erase activated for selected sector
        public static let SectorErase = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    public struct MERValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Erase activated for all user sectors
        public static let MassErase = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    public struct PSIZEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// Program x8
        public static let PSIZE8 = Self(rawValue: 0x0)

        /// Program x16
        public static let PSIZE16 = Self(rawValue: 0x1)

        /// Program x32
        public static let PSIZE32 = Self(rawValue: 0x2)

        /// Program x64
        public static let PSIZE64 = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    public struct STRTValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Trigger an erase operation
        public static let Start = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    public struct EOPIEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// End of operation interrupt disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// End of operation interrupt enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    public struct ERRIEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Error interrupt generation disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Error interrupt generation enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    public struct LOCKValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// FLASH_CR register is unlocked
        public static let Unlocked = Self(rawValue: 0x0)

        /// FLASH_CR register is locked
        public static let Locked = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
