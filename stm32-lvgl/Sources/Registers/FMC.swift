// Generated by svd2swift.

import MMIO

/// Flexible memory controller
@RegisterBlock
public struct FMC {
    /// SRAM/NOR-Flash chip-select control register 1
    @RegisterBlock(offset: 0x0)
    public var bcr1: Register<BCR1>

    /// SRAM/NOR-Flash chip-select timing register 1
    @RegisterBlock(offset: 0x4, stride: 0x8, count: 4)
    public var btr: RegisterArray<BTR>

    /// SRAM/NOR-Flash chip-select control register 2
    @RegisterBlock(offset: 0x8, stride: 0x8, count: 3)
    public var bcr: RegisterArray<BCR>

    /// PC Card/NAND Flash control register
    @RegisterBlock(offset: 0x80)
    public var pcr: Register<PCR>

    /// FIFO status and interrupt register
    @RegisterBlock(offset: 0x84)
    public var sr: Register<SR>

    /// Common memory space timing register
    @RegisterBlock(offset: 0x88)
    public var pmem: Register<PMEM>

    /// Attribute memory space timing register
    @RegisterBlock(offset: 0x8c)
    public var patt: Register<PATT>

    /// ECC result register
    @RegisterBlock(offset: 0x94)
    public var eccr: Register<ECCR>

    /// SRAM/NOR-Flash write timing registers 1
    @RegisterBlock(offset: 0x104, stride: 0x8, count: 4)
    public var bwtr: RegisterArray<BWTR>

    /// SDRAM Control Register 1
    @RegisterBlock(offset: 0x140, stride: 0x4, count: 2)
    public var sdcr: RegisterArray<SDCR>

    /// SDRAM Timing register 1
    @RegisterBlock(offset: 0x148, stride: 0x4, count: 2)
    public var sdtr: RegisterArray<SDTR>

    /// SDRAM Command Mode register
    @RegisterBlock(offset: 0x150)
    public var sdcmr: Register<SDCMR>

    /// SDRAM Refresh Timer register
    @RegisterBlock(offset: 0x154)
    public var sdrtr: Register<SDRTR>

    /// SDRAM Status register
    @RegisterBlock(offset: 0x158)
    public var sdsr: Register<SDSR>
}

extension FMC {
    /// SRAM/NOR-Flash chip-select control register 1
    @Register(bitWidth: 32)
    public struct BCR1 {
        /// CCLKEN
        @ReadWrite(bits: 20..<21, as: CCLKENValues.self)
        public var cclken: CCLKEN

        /// CBURSTRW
        @ReadWrite(bits: 19..<20, as: CBURSTRWValues.self)
        public var cburstrw: CBURSTRW

        /// ASYNCWAIT
        @ReadWrite(bits: 15..<16, as: ASYNCWAITValues.self)
        public var asyncwait: ASYNCWAIT

        /// EXTMOD
        @ReadWrite(bits: 14..<15, as: EXTMODValues.self)
        public var extmod: EXTMOD

        /// WAITEN
        @ReadWrite(bits: 13..<14, as: WAITENValues.self)
        public var waiten: WAITEN

        /// WREN
        @ReadWrite(bits: 12..<13, as: WRENValues.self)
        public var wren: WREN

        /// WAITCFG
        @ReadWrite(bits: 11..<12, as: WAITCFGValues.self)
        public var waitcfg: WAITCFG

        /// WAITPOL
        @ReadWrite(bits: 9..<10, as: WAITPOLValues.self)
        public var waitpol: WAITPOL

        /// BURSTEN
        @ReadWrite(bits: 8..<9, as: BURSTENValues.self)
        public var bursten: BURSTEN

        /// FACCEN
        @ReadWrite(bits: 6..<7, as: FACCENValues.self)
        public var faccen: FACCEN

        /// MWID
        @ReadWrite(bits: 4..<6, as: MWIDValues.self)
        public var mwid: MWID

        /// MTYP
        @ReadWrite(bits: 2..<4, as: MTYPValues.self)
        public var mtyp: MTYP

        /// MUXEN
        @ReadWrite(bits: 1..<2, as: MUXENValues.self)
        public var muxen: MUXEN

        /// MBKEN
        @ReadWrite(bits: 0..<1, as: MBKENValues.self)
        public var mbken: MBKEN

        /// WRAPMOD
        @ReadWrite(bits: 10..<11)
        public var wrapmod: WRAPMOD

        /// Write FIFO disable
        @ReadWrite(bits: 21..<22, as: WFDISValues.self)
        public var wfdis: WFDIS

        /// CRAM page size
        @ReadWrite(bits: 16..<19, as: CPSIZEValues.self)
        public var cpsize: CPSIZE
    }

    /// SRAM/NOR-Flash chip-select timing register 1
    @Register(bitWidth: 32)
    public struct BTR {
        /// ACCMOD
        @ReadWrite(bits: 28..<30, as: ACCMODValues.self)
        public var accmod: ACCMOD

        /// DATLAT
        @ReadWrite(bits: 24..<28)
        public var datlat: DATLAT

        /// CLKDIV
        @ReadWrite(bits: 20..<24)
        public var clkdiv: CLKDIV

        /// BUSTURN
        @ReadWrite(bits: 16..<20)
        public var busturn: BUSTURN

        /// DATAST
        @ReadWrite(bits: 8..<16)
        public var datast: DATAST

        /// ADDHLD
        @ReadWrite(bits: 4..<8)
        public var addhld: ADDHLD

        /// ADDSET
        @ReadWrite(bits: 0..<4)
        public var addset: ADDSET
    }

    /// SRAM/NOR-Flash chip-select control register 2
    @Register(bitWidth: 32)
    public struct BCR {
        /// CBURSTRW
        @ReadWrite(bits: 19..<20, as: CBURSTRWValues.self)
        public var cburstrw: CBURSTRW

        /// ASYNCWAIT
        @ReadWrite(bits: 15..<16, as: ASYNCWAITValues.self)
        public var asyncwait: ASYNCWAIT

        /// EXTMOD
        @ReadWrite(bits: 14..<15, as: EXTMODValues.self)
        public var extmod: EXTMOD

        /// WAITEN
        @ReadWrite(bits: 13..<14, as: WAITENValues.self)
        public var waiten: WAITEN

        /// WREN
        @ReadWrite(bits: 12..<13, as: WRENValues.self)
        public var wren: WREN

        /// WAITCFG
        @ReadWrite(bits: 11..<12, as: WAITCFGValues.self)
        public var waitcfg: WAITCFG

        /// WRAPMOD
        @ReadWrite(bits: 10..<11)
        public var wrapmod: WRAPMOD

        /// WAITPOL
        @ReadWrite(bits: 9..<10, as: WAITPOLValues.self)
        public var waitpol: WAITPOL

        /// BURSTEN
        @ReadWrite(bits: 8..<9, as: BURSTENValues.self)
        public var bursten: BURSTEN

        /// FACCEN
        @ReadWrite(bits: 6..<7, as: FACCENValues.self)
        public var faccen: FACCEN

        /// MWID
        @ReadWrite(bits: 4..<6, as: MWIDValues.self)
        public var mwid: MWID

        /// MTYP
        @ReadWrite(bits: 2..<4, as: MTYPValues.self)
        public var mtyp: MTYP

        /// MUXEN
        @ReadWrite(bits: 1..<2, as: MUXENValues.self)
        public var muxen: MUXEN

        /// MBKEN
        @ReadWrite(bits: 0..<1, as: MBKENValues.self)
        public var mbken: MBKEN

        /// CRAM page size
        @ReadWrite(bits: 16..<19, as: CPSIZEValues.self)
        public var cpsize: CPSIZE
    }

    /// PC Card/NAND Flash control register
    @Register(bitWidth: 32)
    public struct PCR {
        /// ECCPS
        @ReadWrite(bits: 17..<20, as: ECCPSValues.self)
        public var eccps: ECCPS

        /// TAR
        @ReadWrite(bits: 13..<17)
        public var tar: TAR

        /// TCLR
        @ReadWrite(bits: 9..<13)
        public var tclr: TCLR

        /// ECCEN
        @ReadWrite(bits: 6..<7, as: ECCENValues.self)
        public var eccen: ECCEN

        /// PWID
        @ReadWrite(bits: 4..<6, as: PWIDValues.self)
        public var pwid: PWID

        /// PTYP
        @ReadWrite(bits: 3..<4, as: PTYPValues.self)
        public var ptyp: PTYP

        /// PBKEN
        @ReadWrite(bits: 2..<3, as: PBKENValues.self)
        public var pbken: PBKEN

        /// PWAITEN
        @ReadWrite(bits: 1..<2, as: PWAITENValues.self)
        public var pwaiten: PWAITEN
    }

    /// FIFO status and interrupt register
    @Register(bitWidth: 32)
    public struct SR {
        /// FEMPT
        @ReadOnly(bits: 6..<7)
        public var fempt: FEMPT

        /// IFEN
        @ReadWrite(bits: 5..<6, as: IFENValues.self)
        public var ifen: IFEN

        /// ILEN
        @ReadWrite(bits: 4..<5, as: ILENValues.self)
        public var ilen: ILEN

        /// IREN
        @ReadWrite(bits: 3..<4, as: IRENValues.self)
        public var iren: IREN

        /// IFS
        @ReadWrite(bits: 2..<3, as: IFSValues.self)
        public var ifs: IFS

        /// ILS
        @ReadWrite(bits: 1..<2, as: ILSValues.self)
        public var ils: ILS

        /// IRS
        @ReadWrite(bits: 0..<1, as: IRSValues.self)
        public var irs: IRS
    }

    /// Common memory space timing register
    @Register(bitWidth: 32)
    public struct PMEM {
        /// MEMHIZx
        @ReadWrite(bits: 24..<32)
        public var memhiz: MEMHIZ

        /// MEMHOLDx
        @ReadWrite(bits: 16..<24)
        public var memhold: MEMHOLD

        /// MEMWAITx
        @ReadWrite(bits: 8..<16)
        public var memwait: MEMWAIT

        /// MEMSETx
        @ReadWrite(bits: 0..<8)
        public var memset: MEMSET
    }

    /// Attribute memory space timing register
    @Register(bitWidth: 32)
    public struct PATT {
        /// ATTHIZx
        @ReadWrite(bits: 24..<32)
        public var atthiz: ATTHIZ

        /// ATTHOLDx
        @ReadWrite(bits: 16..<24)
        public var atthold: ATTHOLD

        /// ATTWAITx
        @ReadWrite(bits: 8..<16)
        public var attwait: ATTWAIT

        /// ATTSETx
        @ReadWrite(bits: 0..<8)
        public var attset: ATTSET
    }

    /// ECC result register
    @Register(bitWidth: 32)
    public struct ECCR {
        /// ECCx
        @ReadOnly(bits: 0..<32)
        public var ecc: ECC
    }

    /// SRAM/NOR-Flash write timing registers 1
    @Register(bitWidth: 32)
    public struct BWTR {
        /// ACCMOD
        @ReadWrite(bits: 28..<30, as: ACCMODValues.self)
        public var accmod: ACCMOD

        /// DATLAT
        @ReadWrite(bits: 24..<28)
        public var datlat: DATLAT

        /// CLKDIV
        @ReadWrite(bits: 20..<24)
        public var clkdiv: CLKDIV

        /// DATAST
        @ReadWrite(bits: 8..<16)
        public var datast: DATAST

        /// ADDHLD
        @ReadWrite(bits: 4..<8)
        public var addhld: ADDHLD

        /// ADDSET
        @ReadWrite(bits: 0..<4)
        public var addset: ADDSET

        /// Bus turnaround phase duration
        @ReadWrite(bits: 16..<20)
        public var busturn: BUSTURN
    }

    /// SDRAM Control Register 1
    @Register(bitWidth: 32)
    public struct SDCR {
        /// Number of column address bits
        @ReadWrite(bits: 0..<2, as: NCValues.self)
        public var nc: NC

        /// Number of row address bits
        @ReadWrite(bits: 2..<4, as: NRValues.self)
        public var nr: NR

        /// Memory data bus width
        @ReadWrite(bits: 4..<6, as: MWIDValues.self)
        public var mwid: MWID

        /// Number of internal banks
        @ReadWrite(bits: 6..<7, as: NBValues.self)
        public var nb: NB

        /// CAS latency
        @ReadWrite(bits: 7..<9, as: CASValues.self)
        public var cas: CAS

        /// Write protection
        @ReadWrite(bits: 9..<10, as: WPValues.self)
        public var wp: WP

        /// SDRAM clock configuration
        @ReadWrite(bits: 10..<12, as: SDCLKValues.self)
        public var sdclk: SDCLK

        /// Burst read
        @ReadWrite(bits: 12..<13, as: RBURSTValues.self)
        public var rburst: RBURST

        /// Read pipe
        @ReadWrite(bits: 13..<15, as: RPIPEValues.self)
        public var rpipe: RPIPE
    }

    /// SDRAM Timing register 1
    @Register(bitWidth: 32)
    public struct SDTR {
        /// Load Mode Register to Active
        @ReadWrite(bits: 0..<4)
        public var tmrd: TMRD

        /// Exit self-refresh delay
        @ReadWrite(bits: 4..<8)
        public var txsr: TXSR

        /// Self refresh time
        @ReadWrite(bits: 8..<12)
        public var tras: TRAS

        /// Row cycle delay
        @ReadWrite(bits: 12..<16)
        public var trc: TRC

        /// Recovery delay
        @ReadWrite(bits: 16..<20)
        public var twr: TWR

        /// Row precharge delay
        @ReadWrite(bits: 20..<24)
        public var trp: TRP

        /// Row to column delay
        @ReadWrite(bits: 24..<28)
        public var trcd: TRCD
    }

    /// SDRAM Command Mode register
    @Register(bitWidth: 32)
    public struct SDCMR {
        /// Command mode
        @WriteOnly(bits: 0..<3)
        public var mode: MODE

        /// Command target bank 2
        @WriteOnly(bits: 3..<4)
        public var ctb2: CTB2

        /// Command target bank 1
        @WriteOnly(bits: 4..<5)
        public var ctb1: CTB1

        /// Number of Auto-refresh
        @ReadWrite(bits: 5..<9)
        public var nrfs: NRFS

        /// Mode Register definition
        @ReadWrite(bits: 9..<22)
        public var mrd: MRD
    }

    /// SDRAM Refresh Timer register
    @Register(bitWidth: 32)
    public struct SDRTR {
        /// Clear Refresh error flag
        @WriteOnly(bits: 0..<1)
        public var cre: CRE

        /// Refresh Timer Count
        @ReadWrite(bits: 1..<14)
        public var count: COUNT

        /// RES Interrupt Enable
        @ReadWrite(bits: 14..<15, as: REIEValues.self)
        public var reie: REIE
    }

    /// SDRAM Status register
    @Register(bitWidth: 32)
    public struct SDSR {
        /// Refresh error flag
        @ReadOnly(bits: 0..<1)
        public var re: RE

        /// Status Mode for Bank 1
        @ReadOnly(bits: 1..<3)
        public var modes1: MODES1

        /// Status Mode for Bank 2
        @ReadOnly(bits: 3..<5)
        public var modes2: MODES2

        /// Busy status
        @ReadOnly(bits: 5..<6)
        public var busy: BUSY
    }
}

extension FMC.BCR1 {
    public struct CCLKENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// The FMC_CLK is generated continuously during asynchronous and synchronous access. The FMC_CLK clock is activated when the CCLKEN is set
        public static let Disabled = Self(rawValue: 0x0)

        /// The FMC_CLK is only generated during the synchronous memory access (read/write transaction)
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct CBURSTRWValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Write operations are always performed in asynchronous mode
        public static let Disabled = Self(rawValue: 0x0)

        /// Write operations are performed in synchronous mode
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct ASYNCWAITValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Wait signal not used in asynchronous mode
        public static let Disabled = Self(rawValue: 0x0)

        /// Wait signal used even in asynchronous mode
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct EXTMODValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Values inside the FMC_BWTR are not taken into account
        public static let Disabled = Self(rawValue: 0x0)

        /// Values inside the FMC_BWTR are taken into account
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct WAITENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Values inside the FMC_BWTR are taken into account
        public static let Disabled = Self(rawValue: 0x0)

        /// NWAIT signal enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct WRENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Write operations disabled for the bank by the FMC
        public static let Disabled = Self(rawValue: 0x0)

        /// Write operations enabled for the bank by the FMC
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct WAITCFGValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// NWAIT signal is active one data cycle before wait state
        public static let BeforeWaitState = Self(rawValue: 0x0)

        /// NWAIT signal is active during wait state
        public static let DuringWaitState = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct WAITPOLValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// NWAIT active low
        public static let ActiveLow = Self(rawValue: 0x0)

        /// NWAIT active high
        public static let ActiveHigh = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct BURSTENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Burst mode disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Burst mode enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct FACCENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Corresponding NOR Flash memory access is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Corresponding NOR Flash memory access is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct MWIDValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// Memory data bus width 8 bits
        public static let Bits8 = Self(rawValue: 0x0)

        /// Memory data bus width 16 bits
        public static let Bits16 = Self(rawValue: 0x1)

        /// Memory data bus width 32 bits
        public static let Bits32 = Self(rawValue: 0x2)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct MTYPValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// SRAM memory type
        public static let SRAM = Self(rawValue: 0x0)

        /// PSRAM (CRAM) memory type
        public static let PSRAM = Self(rawValue: 0x1)

        /// NOR Flash/OneNAND Flash
        public static let Flash = Self(rawValue: 0x2)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct MUXENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Address/Data non-multiplexed
        public static let Disabled = Self(rawValue: 0x0)

        /// Address/Data multiplexed on databus
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct MBKENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Corresponding memory bank is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Corresponding memory bank is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct WFDISValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Write FIFO enabled
        public static let Enabled = Self(rawValue: 0x0)

        /// Write FIFO disabled
        public static let Disabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR1 {
    public struct CPSIZEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 3

        /// No burst split when crossing page boundary
        public static let NoBurstSplit = Self(rawValue: 0x0)

        /// 128 bytes CRAM page size
        public static let Bytes128 = Self(rawValue: 0x1)

        /// 256 bytes CRAM page size
        public static let Bytes256 = Self(rawValue: 0x2)

        /// 512 bytes CRAM page size
        public static let Bytes512 = Self(rawValue: 0x3)

        /// 1024 bytes CRAM page size
        public static let Bytes1024 = Self(rawValue: 0x4)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BTR {
    public struct ACCMODValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// Access mode A
        public static let A = Self(rawValue: 0x0)

        /// Access mode B
        public static let B = Self(rawValue: 0x1)

        /// Access mode C
        public static let C = Self(rawValue: 0x2)

        /// Access mode D
        public static let D = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct CBURSTRWValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Write operations are always performed in asynchronous mode
        public static let Disabled = Self(rawValue: 0x0)

        /// Write operations are performed in synchronous mode
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct ASYNCWAITValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Wait signal not used in asynchronous mode
        public static let Disabled = Self(rawValue: 0x0)

        /// Wait signal used even in asynchronous mode
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct EXTMODValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Values inside the FMC_BWTR are not taken into account
        public static let Disabled = Self(rawValue: 0x0)

        /// Values inside the FMC_BWTR are taken into account
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct WAITENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Values inside the FMC_BWTR are taken into account
        public static let Disabled = Self(rawValue: 0x0)

        /// NWAIT signal enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct WRENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Write operations disabled for the bank by the FMC
        public static let Disabled = Self(rawValue: 0x0)

        /// Write operations enabled for the bank by the FMC
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct WAITCFGValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// NWAIT signal is active one data cycle before wait state
        public static let BeforeWaitState = Self(rawValue: 0x0)

        /// NWAIT signal is active during wait state
        public static let DuringWaitState = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct WAITPOLValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// NWAIT active low
        public static let ActiveLow = Self(rawValue: 0x0)

        /// NWAIT active high
        public static let ActiveHigh = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct BURSTENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Burst mode disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Burst mode enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct FACCENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Corresponding NOR Flash memory access is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Corresponding NOR Flash memory access is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct MWIDValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// Memory data bus width 8 bits
        public static let Bits8 = Self(rawValue: 0x0)

        /// Memory data bus width 16 bits
        public static let Bits16 = Self(rawValue: 0x1)

        /// Memory data bus width 32 bits
        public static let Bits32 = Self(rawValue: 0x2)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct MTYPValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// SRAM memory type
        public static let SRAM = Self(rawValue: 0x0)

        /// PSRAM (CRAM) memory type
        public static let PSRAM = Self(rawValue: 0x1)

        /// NOR Flash/OneNAND Flash
        public static let Flash = Self(rawValue: 0x2)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct MUXENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Address/Data non-multiplexed
        public static let Disabled = Self(rawValue: 0x0)

        /// Address/Data multiplexed on databus
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct MBKENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Corresponding memory bank is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Corresponding memory bank is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BCR {
    public struct CPSIZEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 3

        /// No burst split when crossing page boundary
        public static let NoBurstSplit = Self(rawValue: 0x0)

        /// 128 bytes CRAM page size
        public static let Bytes128 = Self(rawValue: 0x1)

        /// 256 bytes CRAM page size
        public static let Bytes256 = Self(rawValue: 0x2)

        /// 512 bytes CRAM page size
        public static let Bytes512 = Self(rawValue: 0x3)

        /// 1024 bytes CRAM page size
        public static let Bytes1024 = Self(rawValue: 0x4)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.PCR {
    public struct ECCPSValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 3

        /// ECC page size 256 bytes
        public static let Bytes256 = Self(rawValue: 0x0)

        /// ECC page size 512 bytes
        public static let Bytes512 = Self(rawValue: 0x1)

        /// ECC page size 1024 bytes
        public static let Bytes1024 = Self(rawValue: 0x2)

        /// ECC page size 2048 bytes
        public static let Bytes2048 = Self(rawValue: 0x3)

        /// ECC page size 4096 bytes
        public static let Bytes4096 = Self(rawValue: 0x4)

        /// ECC page size 8192 bytes
        public static let Bytes8192 = Self(rawValue: 0x5)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.PCR {
    public struct ECCENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// ECC logic is disabled and reset
        public static let Disabled = Self(rawValue: 0x0)

        /// ECC logic is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.PCR {
    public struct PWIDValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// External memory device width 8 bits
        public static let Bits8 = Self(rawValue: 0x0)

        /// External memory device width 16 bits
        public static let Bits16 = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.PCR {
    public struct PTYPValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// NAND Flash
        public static let NANDFlash = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.PCR {
    public struct PBKENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Corresponding memory bank is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Corresponding memory bank is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.PCR {
    public struct PWAITENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Wait feature disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Wait feature enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SR {
    public struct IFENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Interrupt falling edge detection request disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Interrupt falling edge detection request enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SR {
    public struct ILENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Interrupt high-level detection request disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Interrupt high-level detection request enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SR {
    public struct IRENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Interrupt rising edge detection request disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Interrupt rising edge detection request enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SR {
    public struct IFSValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Interrupt falling edge did not occur
        public static let DidNotOccur = Self(rawValue: 0x0)

        /// Interrupt falling edge occurred
        public static let Occurred = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SR {
    public struct ILSValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Interrupt high-level did not occur
        public static let DidNotOccur = Self(rawValue: 0x0)

        /// Interrupt high-level occurred
        public static let Occurred = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SR {
    public struct IRSValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Interrupt rising edge did not occur
        public static let DidNotOccur = Self(rawValue: 0x0)

        /// Interrupt rising edge occurred
        public static let Occurred = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.BWTR {
    public struct ACCMODValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// Access mode A
        public static let A = Self(rawValue: 0x0)

        /// Access mode B
        public static let B = Self(rawValue: 0x1)

        /// Access mode C
        public static let C = Self(rawValue: 0x2)

        /// Access mode D
        public static let D = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SDCR {
    public struct NCValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// 8 bits
        public static let Bits8 = Self(rawValue: 0x0)

        /// 9 bits
        public static let Bits9 = Self(rawValue: 0x1)

        /// 10 bits
        public static let Bits10 = Self(rawValue: 0x2)

        /// 11 bits
        public static let Bits11 = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SDCR {
    public struct NRValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// 11 bits
        public static let Bits11 = Self(rawValue: 0x0)

        /// 12 bits
        public static let Bits12 = Self(rawValue: 0x1)

        /// 13 bits
        public static let Bits13 = Self(rawValue: 0x2)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SDCR {
    public struct MWIDValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// Memory data bus width 8 bits
        public static let Bits8 = Self(rawValue: 0x0)

        /// Memory data bus width 16 bits
        public static let Bits16 = Self(rawValue: 0x1)

        /// Memory data bus width 32 bits
        public static let Bits32 = Self(rawValue: 0x2)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SDCR {
    public struct NBValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Two internal Banks
        public static let NB2 = Self(rawValue: 0x0)

        /// Four internal Banks
        public static let NB4 = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SDCR {
    public struct CASValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// 1 cycle
        public static let Clocks1 = Self(rawValue: 0x1)

        /// 2 cycles
        public static let Clocks2 = Self(rawValue: 0x2)

        /// 3 cycles
        public static let Clocks3 = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SDCR {
    public struct WPValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Write accesses allowed
        public static let Disabled = Self(rawValue: 0x0)

        /// Write accesses ignored
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SDCR {
    public struct SDCLKValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// SDCLK clock disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// SDCLK period = 2 x HCLK period
        public static let Div2 = Self(rawValue: 0x2)

        /// SDCLK period = 3 x HCLK period
        public static let Div3 = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SDCR {
    public struct RBURSTValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Single read requests are not managed as bursts
        public static let Disabled = Self(rawValue: 0x0)

        /// Single read requests are always managed as bursts
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SDCR {
    public struct RPIPEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// No clock cycle delay
        public static let NoDelay = Self(rawValue: 0x0)

        /// One clock cycle delay
        public static let Clocks1 = Self(rawValue: 0x1)

        /// Two clock cycles delay
        public static let Clocks2 = Self(rawValue: 0x2)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FMC.SDRTR {
    public struct REIEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Interrupt is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Interrupt is generated if RE = 1
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
