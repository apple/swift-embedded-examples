// Generated by svd2swift.

import MMIO

/// Reset and clock control
@RegisterBlock
public struct RCC {
    /// clock control register
    @RegisterBlock(offset: 0x0)
    public var cr: Register<CR>

    /// PLL configuration register
    @RegisterBlock(offset: 0x4)
    public var pllcfgr: Register<PLLCFGR>

    /// clock configuration register
    @RegisterBlock(offset: 0x8)
    public var cfgr: Register<CFGR>

    /// clock interrupt register
    @RegisterBlock(offset: 0xc)
    public var cir: Register<CIR>

    /// AHB1 peripheral reset register
    @RegisterBlock(offset: 0x10)
    public var ahb1rstr: Register<AHB1RSTR>

    /// AHB2 peripheral reset register
    @RegisterBlock(offset: 0x14)
    public var ahb2rstr: Register<AHB2RSTR>

    /// AHB3 peripheral reset register
    @RegisterBlock(offset: 0x18)
    public var ahb3rstr: Register<AHB3RSTR>

    /// APB1 peripheral reset register
    @RegisterBlock(offset: 0x20)
    public var apb1rstr: Register<APB1RSTR>

    /// APB2 peripheral reset register
    @RegisterBlock(offset: 0x24)
    public var apb2rstr: Register<APB2RSTR>

    /// AHB1 peripheral clock register
    @RegisterBlock(offset: 0x30)
    public var ahb1enr: Register<AHB1ENR>

    /// AHB2 peripheral clock enable register
    @RegisterBlock(offset: 0x34)
    public var ahb2enr: Register<AHB2ENR>

    /// AHB3 peripheral clock enable register
    @RegisterBlock(offset: 0x38)
    public var ahb3enr: Register<AHB3ENR>

    /// APB1 peripheral clock enable register
    @RegisterBlock(offset: 0x40)
    public var apb1enr: Register<APB1ENR>

    /// APB2 peripheral clock enable register
    @RegisterBlock(offset: 0x44)
    public var apb2enr: Register<APB2ENR>

    /// AHB1 peripheral clock enable in low power mode register
    @RegisterBlock(offset: 0x50)
    public var ahb1lpenr: Register<AHB1LPENR>

    /// AHB2 peripheral clock enable in low power mode register
    @RegisterBlock(offset: 0x54)
    public var ahb2lpenr: Register<AHB2LPENR>

    /// AHB3 peripheral clock enable in low power mode register
    @RegisterBlock(offset: 0x58)
    public var ahb3lpenr: Register<AHB3LPENR>

    /// APB1 peripheral clock enable in low power mode register
    @RegisterBlock(offset: 0x60)
    public var apb1lpenr: Register<APB1LPENR>

    /// APB2 peripheral clock enabled in low power mode register
    @RegisterBlock(offset: 0x64)
    public var apb2lpenr: Register<APB2LPENR>

    /// Backup domain control register
    @RegisterBlock(offset: 0x70)
    public var bdcr: Register<BDCR>

    /// clock control & status register
    @RegisterBlock(offset: 0x74)
    public var csr: Register<CSR>

    /// spread spectrum clock generation register
    @RegisterBlock(offset: 0x80)
    public var sscgr: Register<SSCGR>

    /// PLLI2S configuration register
    @RegisterBlock(offset: 0x84)
    public var plli2scfgr: Register<PLLI2SCFGR>

    /// PLL configuration register
    @RegisterBlock(offset: 0x88)
    public var pllsaicfgr: Register<PLLSAICFGR>

    /// dedicated clocks configuration register
    @RegisterBlock(offset: 0x8c)
    public var dckcfgr1: Register<DCKCFGR1>

    /// dedicated clocks configuration register
    @RegisterBlock(offset: 0x90)
    public var dckcfgr2: Register<DCKCFGR2>
}

extension RCC {
    /// clock control register
    @Register(bitWidth: 32)
    public struct CR {
        /// PLLI2S clock ready flag
        @ReadOnly(bits: 27..<28)
        public var plli2srdy: PLLI2SRDY

        /// PLLI2S enable
        @ReadWrite(bits: 26..<27)
        public var plli2son: PLLI2SON

        /// Main PLL (PLL) clock ready flag
        @ReadOnly(bits: 25..<26)
        public var pllrdy: PLLRDY

        /// Main PLL (PLL) enable
        @ReadWrite(bits: 24..<25)
        public var pllon: PLLON

        /// Clock security system enable
        @ReadWrite(bits: 19..<20, as: CSSONValues.self)
        public var csson: CSSON

        /// HSE clock bypass
        @ReadWrite(bits: 18..<19, as: HSEBYPValues.self)
        public var hsebyp: HSEBYP

        /// HSE clock ready flag
        @ReadOnly(bits: 17..<18)
        public var hserdy: HSERDY

        /// HSE clock enable
        @ReadWrite(bits: 16..<17)
        public var hseon: HSEON

        /// Internal high-speed clock calibration
        @ReadOnly(bits: 8..<16)
        public var hsical: HSICAL

        /// Internal high-speed clock trimming
        @ReadWrite(bits: 3..<8)
        public var hsitrim: HSITRIM

        /// Internal high-speed clock ready flag
        @ReadOnly(bits: 1..<2)
        public var hsirdy: HSIRDY

        /// Internal high-speed clock enable
        @ReadWrite(bits: 0..<1, as: HSIONValues.self)
        public var hsion: HSION

        /// PLLSAI clock ready flag
        @ReadOnly(bits: 29..<30)
        public var pllsairdy: PLLSAIRDY

        /// PLLSAI enable
        @ReadWrite(bits: 28..<29)
        public var pllsaion: PLLSAION
    }

    /// PLL configuration register
    @Register(bitWidth: 32)
    public struct PLLCFGR {
        /// Main PLL(PLL) and audio PLL (PLLI2S) entry clock source
        @ReadWrite(bits: 22..<23, as: PLLSRCValues.self)
        public var pllsrc: PLLSRC

        /// Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
        @ReadWrite(bits: 0..<6)
        public var pllm: PLLM

        /// Main PLL (PLL) multiplication factor for VCO
        @ReadWrite(bits: 6..<15)
        public var plln: PLLN

        /// Main PLL (PLL) division factor for main system clock
        @ReadWrite(bits: 16..<18, as: PLLPValues.self)
        public var pllp: PLLP

        /// Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
        @ReadWrite(bits: 24..<28)
        public var pllq: PLLQ
    }

    /// clock configuration register
    @Register(bitWidth: 32)
    public struct CFGR {
        /// Microcontroller clock output 2
        @ReadWrite(bits: 30..<32, as: MCO2Values.self)
        public var mco2: MCO2

        /// MCO2 prescaler
        @ReadWrite(bits: 27..<30)
        public var mco2pre: MCO2PRE

        /// MCO1 prescaler
        @ReadWrite(bits: 24..<27, as: MCO1PREValues.self)
        public var mco1pre: MCO1PRE

        /// I2S clock selection
        @ReadWrite(bits: 23..<24, as: I2SSRCValues.self)
        public var i2ssrc: I2SSRC

        /// Microcontroller clock output 1
        @ReadWrite(bits: 21..<23, as: MCO1Values.self)
        public var mco1: MCO1

        /// HSE division factor for RTC clock
        @ReadWrite(bits: 16..<21)
        public var rtcpre: RTCPRE

        /// APB high-speed prescaler (APB2)
        @ReadWrite(bits: 13..<16)
        public var ppre2: PPRE2

        /// APB Low speed prescaler (APB1)
        @ReadWrite(bits: 10..<13, as: PPRE1Values.self)
        public var ppre1: PPRE1

        /// AHB prescaler
        @ReadWrite(bits: 4..<8, as: HPREValues.self)
        public var hpre: HPRE

        /// System clock switch
        @Reserved(bits: 0..<2, as: SWValues.self)
        public var sw: SW

        /// System clock switch status
        @Reserved(bits: 2..<4)
        public var sws: SWS
    }

    /// clock interrupt register
    @Register(bitWidth: 32)
    public struct CIR {
        /// Clock security system interrupt clear
        @WriteOnly(bits: 23..<24)
        public var cssc: CSSC

        /// PLLSAI Ready Interrupt Clear
        @WriteOnly(bits: 22..<23)
        public var pllsairdyc: PLLSAIRDYC

        /// PLLI2S ready interrupt clear
        @WriteOnly(bits: 21..<22)
        public var plli2srdyc: PLLI2SRDYC

        /// Main PLL(PLL) ready interrupt clear
        @WriteOnly(bits: 20..<21)
        public var pllrdyc: PLLRDYC

        /// HSE ready interrupt clear
        @WriteOnly(bits: 19..<20)
        public var hserdyc: HSERDYC

        /// HSI ready interrupt clear
        @WriteOnly(bits: 18..<19)
        public var hsirdyc: HSIRDYC

        /// LSE ready interrupt clear
        @WriteOnly(bits: 17..<18)
        public var lserdyc: LSERDYC

        /// LSI ready interrupt clear
        @WriteOnly(bits: 16..<17)
        public var lsirdyc: LSIRDYC

        /// PLLSAI Ready Interrupt Enable
        @ReadWrite(bits: 14..<15)
        public var pllsairdyie: PLLSAIRDYIE

        /// PLLI2S ready interrupt enable
        @ReadWrite(bits: 13..<14)
        public var plli2srdyie: PLLI2SRDYIE

        /// Main PLL (PLL) ready interrupt enable
        @ReadWrite(bits: 12..<13)
        public var pllrdyie: PLLRDYIE

        /// HSE ready interrupt enable
        @ReadWrite(bits: 11..<12)
        public var hserdyie: HSERDYIE

        /// HSI ready interrupt enable
        @ReadWrite(bits: 10..<11)
        public var hsirdyie: HSIRDYIE

        /// LSE ready interrupt enable
        @ReadWrite(bits: 9..<10)
        public var lserdyie: LSERDYIE

        /// LSI ready interrupt enable
        @ReadWrite(bits: 8..<9, as: LSIRDYIEValues.self)
        public var lsirdyie: LSIRDYIE

        /// Clock security system interrupt flag
        @ReadOnly(bits: 7..<8)
        public var cssf: CSSF

        /// PLLSAI ready interrupt flag
        @ReadOnly(bits: 6..<7)
        public var pllsairdyf: PLLSAIRDYF

        /// PLLI2S ready interrupt flag
        @ReadOnly(bits: 5..<6)
        public var plli2srdyf: PLLI2SRDYF

        /// Main PLL (PLL) ready interrupt flag
        @ReadOnly(bits: 4..<5)
        public var pllrdyf: PLLRDYF

        /// HSE ready interrupt flag
        @ReadOnly(bits: 3..<4)
        public var hserdyf: HSERDYF

        /// HSI ready interrupt flag
        @ReadOnly(bits: 2..<3)
        public var hsirdyf: HSIRDYF

        /// LSE ready interrupt flag
        @ReadOnly(bits: 1..<2)
        public var lserdyf: LSERDYF

        /// LSI ready interrupt flag
        @ReadOnly(bits: 0..<1)
        public var lsirdyf: LSIRDYF
    }

    /// AHB1 peripheral reset register
    @Register(bitWidth: 32)
    public struct AHB1RSTR {
        /// USB OTG HS module reset
        @ReadWrite(bits: 29..<30)
        public var otghsrst: OTGHSRST

        /// Ethernet MAC reset
        @ReadWrite(bits: 25..<26)
        public var ethmacrst: ETHMACRST

        /// DMA2D reset
        @ReadWrite(bits: 23..<24)
        public var dma2drst: DMA2DRST

        /// DMA2 reset
        @ReadWrite(bits: 22..<23)
        public var dma2rst: DMA2RST

        /// DMA2 reset
        @ReadWrite(bits: 21..<22)
        public var dma1rst: DMA1RST

        /// CRC reset
        @ReadWrite(bits: 12..<13)
        public var crcrst: CRCRST

        /// IO port K reset
        @ReadWrite(bits: 10..<11)
        public var gpiokrst: GPIOKRST

        /// IO port J reset
        @ReadWrite(bits: 9..<10)
        public var gpiojrst: GPIOJRST

        /// IO port I reset
        @ReadWrite(bits: 8..<9)
        public var gpioirst: GPIOIRST

        /// IO port H reset
        @ReadWrite(bits: 7..<8)
        public var gpiohrst: GPIOHRST

        /// IO port G reset
        @ReadWrite(bits: 6..<7)
        public var gpiogrst: GPIOGRST

        /// IO port F reset
        @ReadWrite(bits: 5..<6)
        public var gpiofrst: GPIOFRST

        /// IO port E reset
        @ReadWrite(bits: 4..<5)
        public var gpioerst: GPIOERST

        /// IO port D reset
        @ReadWrite(bits: 3..<4)
        public var gpiodrst: GPIODRST

        /// IO port C reset
        @ReadWrite(bits: 2..<3)
        public var gpiocrst: GPIOCRST

        /// IO port B reset
        @ReadWrite(bits: 1..<2)
        public var gpiobrst: GPIOBRST

        /// IO port A reset
        @ReadWrite(bits: 0..<1, as: GPIOARSTValues.self)
        public var gpioarst: GPIOARST
    }

    /// AHB2 peripheral reset register
    @Register(bitWidth: 32)
    public struct AHB2RSTR {
        /// USB OTG FS module reset
        @ReadWrite(bits: 7..<8)
        public var otgfsrst: OTGFSRST

        /// Random number generator module reset
        @ReadWrite(bits: 6..<7)
        public var rngrst: RNGRST

        /// Hash module reset
        @ReadWrite(bits: 5..<6)
        public var hsahrst: HSAHRST

        /// Cryptographic module reset
        @ReadWrite(bits: 4..<5)
        public var cryprst: CRYPRST

        /// Camera interface reset
        @ReadWrite(bits: 0..<1, as: DCMIRSTValues.self)
        public var dcmirst: DCMIRST
    }

    /// AHB3 peripheral reset register
    @Register(bitWidth: 32)
    public struct AHB3RSTR {
        /// Flexible memory controller module reset
        @ReadWrite(bits: 0..<1, as: FMCRSTValues.self)
        public var fmcrst: FMCRST

        /// Quad SPI memory controller reset
        @ReadWrite(bits: 1..<2)
        public var qspirst: QSPIRST
    }

    /// APB1 peripheral reset register
    @Register(bitWidth: 32)
    public struct APB1RSTR {
        /// TIM2 reset
        @ReadWrite(bits: 0..<1, as: TIM2RSTValues.self)
        public var tim2rst: TIM2RST

        /// TIM3 reset
        @ReadWrite(bits: 1..<2)
        public var tim3rst: TIM3RST

        /// TIM4 reset
        @ReadWrite(bits: 2..<3)
        public var tim4rst: TIM4RST

        /// TIM5 reset
        @ReadWrite(bits: 3..<4)
        public var tim5rst: TIM5RST

        /// TIM6 reset
        @ReadWrite(bits: 4..<5)
        public var tim6rst: TIM6RST

        /// TIM7 reset
        @ReadWrite(bits: 5..<6)
        public var tim7rst: TIM7RST

        /// TIM12 reset
        @ReadWrite(bits: 6..<7)
        public var tim12rst: TIM12RST

        /// TIM13 reset
        @ReadWrite(bits: 7..<8)
        public var tim13rst: TIM13RST

        /// TIM14 reset
        @ReadWrite(bits: 8..<9)
        public var tim14rst: TIM14RST

        /// Window watchdog reset
        @ReadWrite(bits: 11..<12)
        public var wwdgrst: WWDGRST

        /// SPI 2 reset
        @ReadWrite(bits: 14..<15)
        public var spi2rst: SPI2RST

        /// SPI 3 reset
        @ReadWrite(bits: 15..<16)
        public var spi3rst: SPI3RST

        /// USART 2 reset
        @ReadWrite(bits: 17..<18)
        public var usart2rst: USART2RST

        /// USART 3 reset
        @ReadWrite(bits: 18..<19)
        public var usart3rst: USART3RST

        /// USART 4 reset
        @ReadWrite(bits: 19..<20)
        public var uart4rst: UART4RST

        /// USART 5 reset
        @ReadWrite(bits: 20..<21)
        public var uart5rst: UART5RST

        /// I2C 1 reset
        @ReadWrite(bits: 21..<22)
        public var i2c1rst: I2C1RST

        /// I2C 2 reset
        @ReadWrite(bits: 22..<23)
        public var i2c2rst: I2C2RST

        /// I2C3 reset
        @ReadWrite(bits: 23..<24)
        public var i2c3rst: I2C3RST

        /// CAN1 reset
        @ReadWrite(bits: 25..<26)
        public var can1rst: CAN1RST

        /// CAN2 reset
        @ReadWrite(bits: 26..<27)
        public var can2rst: CAN2RST

        /// Power interface reset
        @ReadWrite(bits: 28..<29)
        public var pwrrst: PWRRST

        /// DAC reset
        @ReadWrite(bits: 29..<30)
        public var dacrst: DACRST

        /// UART7 reset
        @ReadWrite(bits: 30..<31)
        public var uart7rst: UART7RST

        /// UART8 reset
        @ReadWrite(bits: 31..<32)
        public var uart8rst: UART8RST

        /// SPDIF-RX reset
        @ReadWrite(bits: 16..<17)
        public var spdifrxrst: SPDIFRXRST

        /// HDMI-CEC reset
        @ReadWrite(bits: 27..<28)
        public var cecrst: CECRST

        /// Low power timer 1 reset
        @ReadWrite(bits: 9..<10)
        public var lptim1rst: LPTIM1RST

        /// I2C 4 reset
        @ReadWrite(bits: 24..<25)
        public var i2c4rst: I2C4RST
    }

    /// APB2 peripheral reset register
    @Register(bitWidth: 32)
    public struct APB2RSTR {
        /// TIM1 reset
        @ReadWrite(bits: 0..<1, as: TIM1RSTValues.self)
        public var tim1rst: TIM1RST

        /// TIM8 reset
        @ReadWrite(bits: 1..<2)
        public var tim8rst: TIM8RST

        /// USART1 reset
        @ReadWrite(bits: 4..<5)
        public var usart1rst: USART1RST

        /// USART6 reset
        @ReadWrite(bits: 5..<6)
        public var usart6rst: USART6RST

        /// ADC interface reset (common to all ADCs)
        @ReadWrite(bits: 8..<9)
        public var adcrst: ADCRST

        /// SPI 1 reset
        @ReadWrite(bits: 12..<13)
        public var spi1rst: SPI1RST

        /// SPI4 reset
        @ReadWrite(bits: 13..<14)
        public var spi4rst: SPI4RST

        /// System configuration controller reset
        @ReadWrite(bits: 14..<15)
        public var syscfgrst: SYSCFGRST

        /// TIM9 reset
        @ReadWrite(bits: 16..<17)
        public var tim9rst: TIM9RST

        /// TIM10 reset
        @ReadWrite(bits: 17..<18)
        public var tim10rst: TIM10RST

        /// TIM11 reset
        @ReadWrite(bits: 18..<19)
        public var tim11rst: TIM11RST

        /// SPI5 reset
        @ReadWrite(bits: 20..<21)
        public var spi5rst: SPI5RST

        /// SPI6 reset
        @ReadWrite(bits: 21..<22)
        public var spi6rst: SPI6RST

        /// SAI1 reset
        @ReadWrite(bits: 22..<23)
        public var sai1rst: SAI1RST

        /// LTDC reset
        @ReadWrite(bits: 26..<27)
        public var ltdcrst: LTDCRST

        /// SAI2 reset
        @ReadWrite(bits: 23..<24)
        public var sai2rst: SAI2RST

        /// SDMMC1 reset
        @ReadWrite(bits: 11..<12)
        public var sdmmc1rst: SDMMC1RST
    }

    /// AHB1 peripheral clock register
    @Register(bitWidth: 32)
    public struct AHB1ENR {
        /// USB OTG HSULPI clock enable
        @ReadWrite(bits: 30..<31)
        public var otghsulpien: OTGHSULPIEN

        /// USB OTG HS clock enable
        @ReadWrite(bits: 29..<30)
        public var otghsen: OTGHSEN

        /// Ethernet PTP clock enable
        @ReadWrite(bits: 28..<29)
        public var ethmacptpen: ETHMACPTPEN

        /// Ethernet Reception clock enable
        @ReadWrite(bits: 27..<28)
        public var ethmacrxen: ETHMACRXEN

        /// Ethernet Transmission clock enable
        @ReadWrite(bits: 26..<27)
        public var ethmactxen: ETHMACTXEN

        /// Ethernet MAC clock enable
        @ReadWrite(bits: 25..<26)
        public var ethmacen: ETHMACEN

        /// DMA2D clock enable
        @ReadWrite(bits: 23..<24)
        public var dma2den: DMA2DEN

        /// DMA2 clock enable
        @ReadWrite(bits: 22..<23)
        public var dma2en: DMA2EN

        /// DMA1 clock enable
        @ReadWrite(bits: 21..<22)
        public var dma1en: DMA1EN

        /// CCM data RAM clock enable
        @ReadWrite(bits: 20..<21)
        public var dtcmramen: DTCMRAMEN

        /// Backup SRAM interface clock enable
        @ReadWrite(bits: 18..<19)
        public var bkpsramen: BKPSRAMEN

        /// CRC clock enable
        @ReadWrite(bits: 12..<13)
        public var crcen: CRCEN

        /// IO port K clock enable
        @ReadWrite(bits: 10..<11)
        public var gpioken: GPIOKEN

        /// IO port J clock enable
        @ReadWrite(bits: 9..<10)
        public var gpiojen: GPIOJEN

        /// IO port I clock enable
        @ReadWrite(bits: 8..<9)
        public var gpioien: GPIOIEN

        /// IO port H clock enable
        @ReadWrite(bits: 7..<8)
        public var gpiohen: GPIOHEN

        /// IO port G clock enable
        @ReadWrite(bits: 6..<7)
        public var gpiogen: GPIOGEN

        /// IO port F clock enable
        @ReadWrite(bits: 5..<6)
        public var gpiofen: GPIOFEN

        /// IO port E clock enable
        @ReadWrite(bits: 4..<5)
        public var gpioeen: GPIOEEN

        /// IO port D clock enable
        @ReadWrite(bits: 3..<4)
        public var gpioden: GPIODEN

        /// IO port C clock enable
        @ReadWrite(bits: 2..<3)
        public var gpiocen: GPIOCEN

        /// IO port B clock enable
        @ReadWrite(bits: 1..<2)
        public var gpioben: GPIOBEN

        /// IO port A clock enable
        @ReadWrite(bits: 0..<1, as: GPIOAENValues.self)
        public var gpioaen: GPIOAEN
    }

    /// AHB2 peripheral clock enable register
    @Register(bitWidth: 32)
    public struct AHB2ENR {
        /// USB OTG FS clock enable
        @ReadWrite(bits: 7..<8)
        public var otgfsen: OTGFSEN

        /// Random number generator clock enable
        @ReadWrite(bits: 6..<7)
        public var rngen: RNGEN

        /// Hash modules clock enable
        @ReadWrite(bits: 5..<6)
        public var hashen: HASHEN

        /// Cryptographic modules clock enable
        @ReadWrite(bits: 4..<5)
        public var crypen: CRYPEN

        /// Camera interface enable
        @ReadWrite(bits: 0..<1, as: DCMIENValues.self)
        public var dcmien: DCMIEN
    }

    /// AHB3 peripheral clock enable register
    @Register(bitWidth: 32)
    public struct AHB3ENR {
        /// Flexible memory controller module clock enable
        @ReadWrite(bits: 0..<1, as: FMCENValues.self)
        public var fmcen: FMCEN

        /// Quad SPI memory controller clock enable
        @ReadWrite(bits: 1..<2)
        public var qspien: QSPIEN
    }

    /// APB1 peripheral clock enable register
    @Register(bitWidth: 32)
    public struct APB1ENR {
        /// TIM2 clock enable
        @ReadWrite(bits: 0..<1, as: TIM2ENValues.self)
        public var tim2en: TIM2EN

        /// TIM3 clock enable
        @ReadWrite(bits: 1..<2)
        public var tim3en: TIM3EN

        /// TIM4 clock enable
        @ReadWrite(bits: 2..<3)
        public var tim4en: TIM4EN

        /// TIM5 clock enable
        @ReadWrite(bits: 3..<4)
        public var tim5en: TIM5EN

        /// TIM6 clock enable
        @ReadWrite(bits: 4..<5)
        public var tim6en: TIM6EN

        /// TIM7 clock enable
        @ReadWrite(bits: 5..<6)
        public var tim7en: TIM7EN

        /// TIM12 clock enable
        @ReadWrite(bits: 6..<7)
        public var tim12en: TIM12EN

        /// TIM13 clock enable
        @ReadWrite(bits: 7..<8)
        public var tim13en: TIM13EN

        /// TIM14 clock enable
        @ReadWrite(bits: 8..<9)
        public var tim14en: TIM14EN

        /// Window watchdog clock enable
        @ReadWrite(bits: 11..<12)
        public var wwdgen: WWDGEN

        /// SPI2 clock enable
        @ReadWrite(bits: 14..<15)
        public var spi2en: SPI2EN

        /// SPI3 clock enable
        @ReadWrite(bits: 15..<16)
        public var spi3en: SPI3EN

        /// USART 2 clock enable
        @ReadWrite(bits: 17..<18)
        public var usart2en: USART2EN

        /// USART3 clock enable
        @ReadWrite(bits: 18..<19)
        public var usart3en: USART3EN

        /// UART4 clock enable
        @ReadWrite(bits: 19..<20)
        public var uart4en: UART4EN

        /// UART5 clock enable
        @ReadWrite(bits: 20..<21)
        public var uart5en: UART5EN

        /// I2C1 clock enable
        @ReadWrite(bits: 21..<22)
        public var i2c1en: I2C1EN

        /// I2C2 clock enable
        @ReadWrite(bits: 22..<23)
        public var i2c2en: I2C2EN

        /// I2C3 clock enable
        @ReadWrite(bits: 23..<24)
        public var i2c3en: I2C3EN

        /// CAN 1 clock enable
        @ReadWrite(bits: 25..<26)
        public var can1en: CAN1EN

        /// CAN 2 clock enable
        @ReadWrite(bits: 26..<27)
        public var can2en: CAN2EN

        /// Power interface clock enable
        @ReadWrite(bits: 28..<29)
        public var pwren: PWREN

        /// DAC interface clock enable
        @ReadWrite(bits: 29..<30)
        public var dacen: DACEN

        /// UART7 clock enable
        @ReadWrite(bits: 30..<31)
        public var uart7en: UART7EN

        /// UART8 clock enable
        @ReadWrite(bits: 31..<32)
        public var uart8en: UART8EN

        /// SPDIF-RX clock enable
        @ReadWrite(bits: 16..<17)
        public var spdifrxen: SPDIFRXEN

        /// HDMI-CEN clock enable
        @ReadWrite(bits: 27..<28)
        public var cecen: CECEN

        /// Low power timer 1 clock enable
        @ReadWrite(bits: 9..<10)
        public var lptim1en: LPTIM1EN

        /// I2C4 clock enable
        @ReadWrite(bits: 24..<25)
        public var i2c4en: I2C4EN
    }

    /// APB2 peripheral clock enable register
    @Register(bitWidth: 32)
    public struct APB2ENR {
        /// TIM1 clock enable
        @ReadWrite(bits: 0..<1, as: TIM1ENValues.self)
        public var tim1en: TIM1EN

        /// TIM8 clock enable
        @ReadWrite(bits: 1..<2)
        public var tim8en: TIM8EN

        /// USART1 clock enable
        @ReadWrite(bits: 4..<5)
        public var usart1en: USART1EN

        /// USART6 clock enable
        @ReadWrite(bits: 5..<6)
        public var usart6en: USART6EN

        /// ADC1 clock enable
        @ReadWrite(bits: 8..<9)
        public var adc1en: ADC1EN

        /// ADC2 clock enable
        @ReadWrite(bits: 9..<10)
        public var adc2en: ADC2EN

        /// ADC3 clock enable
        @ReadWrite(bits: 10..<11)
        public var adc3en: ADC3EN

        /// SPI1 clock enable
        @ReadWrite(bits: 12..<13)
        public var spi1en: SPI1EN

        /// SPI4 clock enable
        @ReadWrite(bits: 13..<14)
        public var spi4en: SPI4EN

        /// System configuration controller clock enable
        @ReadWrite(bits: 14..<15)
        public var syscfgen: SYSCFGEN

        /// TIM9 clock enable
        @ReadWrite(bits: 16..<17)
        public var tim9en: TIM9EN

        /// TIM10 clock enable
        @ReadWrite(bits: 17..<18)
        public var tim10en: TIM10EN

        /// TIM11 clock enable
        @ReadWrite(bits: 18..<19)
        public var tim11en: TIM11EN

        /// SPI5 clock enable
        @ReadWrite(bits: 20..<21)
        public var spi5en: SPI5EN

        /// SPI6 clock enable
        @ReadWrite(bits: 21..<22)
        public var spi6en: SPI6EN

        /// SAI1 clock enable
        @ReadWrite(bits: 22..<23)
        public var sai1en: SAI1EN

        /// LTDC clock enable
        @ReadWrite(bits: 26..<27)
        public var ltdcen: LTDCEN

        /// SAI2 clock enable
        @ReadWrite(bits: 23..<24)
        public var sai2en: SAI2EN

        /// SDMMC1 clock enable
        @ReadWrite(bits: 11..<12)
        public var sdmmc1en: SDMMC1EN
    }

    /// AHB1 peripheral clock enable in low power mode register
    @Register(bitWidth: 32)
    public struct AHB1LPENR {
        /// IO port A clock enable during sleep mode
        @ReadWrite(bits: 0..<1, as: GPIOALPENValues.self)
        public var gpioalpen: GPIOALPEN

        /// IO port B clock enable during Sleep mode
        @ReadWrite(bits: 1..<2)
        public var gpioblpen: GPIOBLPEN

        /// IO port C clock enable during Sleep mode
        @ReadWrite(bits: 2..<3)
        public var gpioclpen: GPIOCLPEN

        /// IO port D clock enable during Sleep mode
        @ReadWrite(bits: 3..<4)
        public var gpiodlpen: GPIODLPEN

        /// IO port E clock enable during Sleep mode
        @ReadWrite(bits: 4..<5)
        public var gpioelpen: GPIOELPEN

        /// IO port F clock enable during Sleep mode
        @ReadWrite(bits: 5..<6)
        public var gpioflpen: GPIOFLPEN

        /// IO port G clock enable during Sleep mode
        @ReadWrite(bits: 6..<7)
        public var gpioglpen: GPIOGLPEN

        /// IO port H clock enable during Sleep mode
        @ReadWrite(bits: 7..<8)
        public var gpiohlpen: GPIOHLPEN

        /// IO port I clock enable during Sleep mode
        @ReadWrite(bits: 8..<9)
        public var gpioilpen: GPIOILPEN

        /// IO port J clock enable during Sleep mode
        @ReadWrite(bits: 9..<10)
        public var gpiojlpen: GPIOJLPEN

        /// IO port K clock enable during Sleep mode
        @ReadWrite(bits: 10..<11)
        public var gpioklpen: GPIOKLPEN

        /// CRC clock enable during Sleep mode
        @ReadWrite(bits: 12..<13)
        public var crclpen: CRCLPEN

        /// Flash interface clock enable during Sleep mode
        @ReadWrite(bits: 15..<16)
        public var flitflpen: FLITFLPEN

        /// SRAM 1interface clock enable during Sleep mode
        @ReadWrite(bits: 16..<17)
        public var sram1lpen: SRAM1LPEN

        /// SRAM 2 interface clock enable during Sleep mode
        @ReadWrite(bits: 17..<18)
        public var sram2lpen: SRAM2LPEN

        /// Backup SRAM interface clock enable during Sleep mode
        @ReadWrite(bits: 18..<19)
        public var bkpsramlpen: BKPSRAMLPEN

        /// SRAM 3 interface clock enable during Sleep mode
        @ReadWrite(bits: 19..<20)
        public var sram3lpen: SRAM3LPEN

        /// DMA1 clock enable during Sleep mode
        @ReadWrite(bits: 21..<22)
        public var dma1lpen: DMA1LPEN

        /// DMA2 clock enable during Sleep mode
        @ReadWrite(bits: 22..<23)
        public var dma2lpen: DMA2LPEN

        /// DMA2D clock enable during Sleep mode
        @ReadWrite(bits: 23..<24)
        public var dma2dlpen: DMA2DLPEN

        /// Ethernet MAC clock enable during Sleep mode
        @ReadWrite(bits: 25..<26)
        public var ethmaclpen: ETHMACLPEN

        /// Ethernet transmission clock enable during Sleep mode
        @ReadWrite(bits: 26..<27)
        public var ethmactxlpen: ETHMACTXLPEN

        /// Ethernet reception clock enable during Sleep mode
        @ReadWrite(bits: 27..<28)
        public var ethmacrxlpen: ETHMACRXLPEN

        /// Ethernet PTP clock enable during Sleep mode
        @ReadWrite(bits: 28..<29)
        public var ethmacptplpen: ETHMACPTPLPEN

        /// USB OTG HS clock enable during Sleep mode
        @ReadWrite(bits: 29..<30)
        public var otghslpen: OTGHSLPEN

        /// USB OTG HS ULPI clock enable during Sleep mode
        @ReadWrite(bits: 30..<31)
        public var otghsulpilpen: OTGHSULPILPEN

        /// AXI to AHB bridge clock enable during Sleep mode
        @ReadWrite(bits: 13..<14)
        public var axilpen: AXILPEN

        /// DTCM RAM interface clock enable during Sleep mode
        @ReadWrite(bits: 20..<21)
        public var dtcmlpen: DTCMLPEN
    }

    /// AHB2 peripheral clock enable in low power mode register
    @Register(bitWidth: 32)
    public struct AHB2LPENR {
        /// USB OTG FS clock enable during Sleep mode
        @ReadWrite(bits: 7..<8)
        public var otgfslpen: OTGFSLPEN

        /// Random number generator clock enable during Sleep mode
        @ReadWrite(bits: 6..<7)
        public var rnglpen: RNGLPEN

        /// Hash modules clock enable during Sleep mode
        @ReadWrite(bits: 5..<6)
        public var hashlpen: HASHLPEN

        /// Cryptography modules clock enable during Sleep mode
        @ReadWrite(bits: 4..<5)
        public var cryplpen: CRYPLPEN

        /// Camera interface enable during Sleep mode
        @ReadWrite(bits: 0..<1, as: DCMILPENValues.self)
        public var dcmilpen: DCMILPEN
    }

    /// AHB3 peripheral clock enable in low power mode register
    @Register(bitWidth: 32)
    public struct AHB3LPENR {
        /// Flexible memory controller module clock enable during Sleep mode
        @ReadWrite(bits: 0..<1, as: FMCLPENValues.self)
        public var fmclpen: FMCLPEN

        /// Quand SPI memory controller clock enable during Sleep mode
        @ReadWrite(bits: 1..<2)
        public var qspilpen: QSPILPEN
    }

    /// APB1 peripheral clock enable in low power mode register
    @Register(bitWidth: 32)
    public struct APB1LPENR {
        /// TIM2 clock enable during Sleep mode
        @ReadWrite(bits: 0..<1, as: TIM2LPENValues.self)
        public var tim2lpen: TIM2LPEN

        /// TIM3 clock enable during Sleep mode
        @ReadWrite(bits: 1..<2)
        public var tim3lpen: TIM3LPEN

        /// TIM4 clock enable during Sleep mode
        @ReadWrite(bits: 2..<3)
        public var tim4lpen: TIM4LPEN

        /// TIM5 clock enable during Sleep mode
        @ReadWrite(bits: 3..<4)
        public var tim5lpen: TIM5LPEN

        /// TIM6 clock enable during Sleep mode
        @ReadWrite(bits: 4..<5)
        public var tim6lpen: TIM6LPEN

        /// TIM7 clock enable during Sleep mode
        @ReadWrite(bits: 5..<6)
        public var tim7lpen: TIM7LPEN

        /// TIM12 clock enable during Sleep mode
        @ReadWrite(bits: 6..<7)
        public var tim12lpen: TIM12LPEN

        /// TIM13 clock enable during Sleep mode
        @ReadWrite(bits: 7..<8)
        public var tim13lpen: TIM13LPEN

        /// TIM14 clock enable during Sleep mode
        @ReadWrite(bits: 8..<9)
        public var tim14lpen: TIM14LPEN

        /// Window watchdog clock enable during Sleep mode
        @ReadWrite(bits: 11..<12)
        public var wwdglpen: WWDGLPEN

        /// SPI2 clock enable during Sleep mode
        @ReadWrite(bits: 14..<15)
        public var spi2lpen: SPI2LPEN

        /// SPI3 clock enable during Sleep mode
        @ReadWrite(bits: 15..<16)
        public var spi3lpen: SPI3LPEN

        /// USART2 clock enable during Sleep mode
        @ReadWrite(bits: 17..<18)
        public var usart2lpen: USART2LPEN

        /// USART3 clock enable during Sleep mode
        @ReadWrite(bits: 18..<19)
        public var usart3lpen: USART3LPEN

        /// UART4 clock enable during Sleep mode
        @ReadWrite(bits: 19..<20)
        public var uart4lpen: UART4LPEN

        /// UART5 clock enable during Sleep mode
        @ReadWrite(bits: 20..<21)
        public var uart5lpen: UART5LPEN

        /// I2C1 clock enable during Sleep mode
        @ReadWrite(bits: 21..<22)
        public var i2c1lpen: I2C1LPEN

        /// I2C2 clock enable during Sleep mode
        @ReadWrite(bits: 22..<23)
        public var i2c2lpen: I2C2LPEN

        /// I2C3 clock enable during Sleep mode
        @ReadWrite(bits: 23..<24)
        public var i2c3lpen: I2C3LPEN

        /// CAN 1 clock enable during Sleep mode
        @ReadWrite(bits: 25..<26)
        public var can1lpen: CAN1LPEN

        /// CAN 2 clock enable during Sleep mode
        @ReadWrite(bits: 26..<27)
        public var can2lpen: CAN2LPEN

        /// Power interface clock enable during Sleep mode
        @ReadWrite(bits: 28..<29)
        public var pwrlpen: PWRLPEN

        /// DAC interface clock enable during Sleep mode
        @ReadWrite(bits: 29..<30)
        public var daclpen: DACLPEN

        /// UART7 clock enable during Sleep mode
        @ReadWrite(bits: 30..<31)
        public var uart7lpen: UART7LPEN

        /// UART8 clock enable during Sleep mode
        @ReadWrite(bits: 31..<32)
        public var uart8lpen: UART8LPEN

        /// SPDIF-RX clock enable during sleep mode
        @ReadWrite(bits: 16..<17)
        public var spdifrxlpen: SPDIFRXLPEN

        /// HDMI-CEN clock enable during Sleep mode
        @ReadWrite(bits: 27..<28)
        public var ceclpen: CECLPEN

        /// low power timer 1 clock enable during Sleep mode
        @ReadWrite(bits: 9..<10)
        public var lptim1lpen: LPTIM1LPEN

        /// I2C4 clock enable during Sleep mode
        @ReadWrite(bits: 24..<25)
        public var i2c4lpen: I2C4LPEN
    }

    /// APB2 peripheral clock enabled in low power mode register
    @Register(bitWidth: 32)
    public struct APB2LPENR {
        /// TIM1 clock enable during Sleep mode
        @ReadWrite(bits: 0..<1, as: TIM1LPENValues.self)
        public var tim1lpen: TIM1LPEN

        /// TIM8 clock enable during Sleep mode
        @ReadWrite(bits: 1..<2)
        public var tim8lpen: TIM8LPEN

        /// USART1 clock enable during Sleep mode
        @ReadWrite(bits: 4..<5)
        public var usart1lpen: USART1LPEN

        /// USART6 clock enable during Sleep mode
        @ReadWrite(bits: 5..<6)
        public var usart6lpen: USART6LPEN

        /// ADC1 clock enable during Sleep mode
        @ReadWrite(bits: 8..<9)
        public var adc1lpen: ADC1LPEN

        /// ADC2 clock enable during Sleep mode
        @ReadWrite(bits: 9..<10)
        public var adc2lpen: ADC2LPEN

        /// ADC 3 clock enable during Sleep mode
        @ReadWrite(bits: 10..<11)
        public var adc3lpen: ADC3LPEN

        /// SPI 1 clock enable during Sleep mode
        @ReadWrite(bits: 12..<13)
        public var spi1lpen: SPI1LPEN

        /// SPI 4 clock enable during Sleep mode
        @ReadWrite(bits: 13..<14)
        public var spi4lpen: SPI4LPEN

        /// System configuration controller clock enable during Sleep mode
        @ReadWrite(bits: 14..<15)
        public var syscfglpen: SYSCFGLPEN

        /// TIM9 clock enable during sleep mode
        @ReadWrite(bits: 16..<17)
        public var tim9lpen: TIM9LPEN

        /// TIM10 clock enable during Sleep mode
        @ReadWrite(bits: 17..<18)
        public var tim10lpen: TIM10LPEN

        /// TIM11 clock enable during Sleep mode
        @ReadWrite(bits: 18..<19)
        public var tim11lpen: TIM11LPEN

        /// SPI 5 clock enable during Sleep mode
        @ReadWrite(bits: 20..<21)
        public var spi5lpen: SPI5LPEN

        /// SPI 6 clock enable during Sleep mode
        @ReadWrite(bits: 21..<22)
        public var spi6lpen: SPI6LPEN

        /// SAI1 clock enable during sleep mode
        @ReadWrite(bits: 22..<23)
        public var sai1lpen: SAI1LPEN

        /// LTDC clock enable during sleep mode
        @ReadWrite(bits: 26..<27)
        public var ltdclpen: LTDCLPEN

        /// SAI2 clock enable during sleep mode
        @ReadWrite(bits: 23..<24)
        public var sai2lpen: SAI2LPEN

        /// SDMMC1 clock enable during Sleep mode
        @ReadWrite(bits: 11..<12)
        public var sdmmc1lpen: SDMMC1LPEN
    }

    /// Backup domain control register
    @Register(bitWidth: 32)
    public struct BDCR {
        /// Backup domain software reset
        @ReadWrite(bits: 16..<17, as: BDRSTValues.self)
        public var bdrst: BDRST

        /// RTC clock enable
        @ReadWrite(bits: 15..<16, as: RTCENValues.self)
        public var rtcen: RTCEN

        /// External low-speed oscillator bypass
        @ReadWrite(bits: 2..<3, as: LSEBYPValues.self)
        public var lsebyp: LSEBYP

        /// External low-speed oscillator ready
        @ReadOnly(bits: 1..<2)
        public var lserdy: LSERDY

        /// External low-speed oscillator enable
        @ReadWrite(bits: 0..<1, as: LSEONValues.self)
        public var lseon: LSEON

        /// LSE oscillator drive capability
        @ReadWrite(bits: 3..<5, as: LSEDRVValues.self)
        public var lsedrv: LSEDRV

        /// RTC clock source selection
        @Reserved(bits: 8..<10, as: RTCSELValues.self)
        public var rtcsel: RTCSEL
    }

    /// clock control & status register
    @Register(bitWidth: 32)
    public struct CSR {
        /// Low-power reset flag
        @ReadWrite(bits: 31..<32)
        public var lpwrrstf: LPWRRSTF

        /// Window watchdog reset flag
        @ReadWrite(bits: 30..<31)
        public var wwdgrstf: WWDGRSTF

        /// Independent watchdog reset flag
        @ReadWrite(bits: 29..<30)
        public var wdgrstf: WDGRSTF

        /// Software reset flag
        @ReadWrite(bits: 28..<29)
        public var sftrstf: SFTRSTF

        /// POR/PDR reset flag
        @ReadWrite(bits: 27..<28)
        public var porrstf: PORRSTF

        /// PIN reset flag
        @ReadWrite(bits: 26..<27)
        public var padrstf: PADRSTF

        /// BOR reset flag
        @ReadWrite(bits: 25..<26)
        public var borrstf: BORRSTF

        /// Remove reset flag
        @ReadWrite(bits: 24..<25)
        public var rmvf: RMVF

        /// Internal low-speed oscillator ready
        @ReadOnly(bits: 1..<2)
        public var lsirdy: LSIRDY

        /// Internal low-speed oscillator enable
        @ReadWrite(bits: 0..<1, as: LSIONValues.self)
        public var lsion: LSION
    }

    /// spread spectrum clock generation register
    @Register(bitWidth: 32)
    public struct SSCGR {
        /// Spread spectrum modulation enable
        @ReadWrite(bits: 31..<32, as: SSCGENValues.self)
        public var sscgen: SSCGEN

        /// Spread Select
        @ReadWrite(bits: 30..<31, as: SPREADSELValues.self)
        public var spreadsel: SPREADSEL

        /// Incrementation step
        @ReadWrite(bits: 13..<28)
        public var incstep: INCSTEP

        /// Modulation period
        @ReadWrite(bits: 0..<13)
        public var modper: MODPER
    }

    /// PLLI2S configuration register
    @Register(bitWidth: 32)
    public struct PLLI2SCFGR {
        /// PLLI2S division factor for I2S clocks
        @ReadWrite(bits: 28..<31)
        public var plli2sr: PLLI2SR

        /// PLLI2S division factor for SAI1 clock
        @ReadWrite(bits: 24..<28)
        public var plli2sq: PLLI2SQ

        /// PLLI2S multiplication factor for VCO
        @ReadWrite(bits: 6..<15)
        public var plli2sn: PLLI2SN

        /// PLLI2S division factor for SPDIFRX clock
        @ReadWrite(bits: 16..<18, as: PLLI2SPValues.self)
        public var plli2sp: PLLI2SP
    }

    /// PLL configuration register
    @Register(bitWidth: 32)
    public struct PLLSAICFGR {
        /// PLLSAI division factor for VCO
        @ReadWrite(bits: 6..<15)
        public var pllsain: PLLSAIN

        /// PLLSAI division factor for 48MHz clock
        @ReadWrite(bits: 16..<18, as: PLLSAIPValues.self)
        public var pllsaip: PLLSAIP

        /// PLLSAI division factor for SAI clock
        @ReadWrite(bits: 24..<28)
        public var pllsaiq: PLLSAIQ

        /// PLLSAI division factor for LCD clock
        @ReadWrite(bits: 28..<31)
        public var pllsair: PLLSAIR
    }

    /// dedicated clocks configuration register
    @Register(bitWidth: 32)
    public struct DCKCFGR1 {
        /// PLLI2S division factor for SAI1 clock
        @ReadWrite(bits: 0..<5, as: PLLI2SDIVQValues.self)
        public var plli2sdivq: PLLI2SDIVQ

        /// PLLSAI division factor for SAI1 clock
        @ReadWrite(bits: 8..<13, as: PLLSAIDIVQValues.self)
        public var pllsaidivq: PLLSAIDIVQ

        /// division factor for LCD_CLK
        @ReadWrite(bits: 16..<18, as: PLLSAIDIVRValues.self)
        public var pllsaidivr: PLLSAIDIVR

        /// SAI1 clock source selection
        @ReadWrite(bits: 20..<22, as: SAI1SELValues.self)
        public var sai1sel: SAI1SEL

        /// SAI2 clock source selection
        @ReadWrite(bits: 22..<24, as: SAI2SELValues.self)
        public var sai2sel: SAI2SEL

        /// Timers clocks prescalers selection
        @ReadWrite(bits: 24..<25, as: TIMPREValues.self)
        public var timpre: TIMPRE
    }

    /// dedicated clocks configuration register
    @Register(bitWidth: 32)
    public struct DCKCFGR2 {
        /// USART 1 clock source selection
        @ReadWrite(bits: 0..<2, as: USART1SELValues.self)
        public var usart1sel: USART1SEL

        /// USART 2 clock source selection
        @ReadWrite(bits: 2..<4, as: USART2SELValues.self)
        public var usart2sel: USART2SEL

        /// USART 3 clock source selection
        @ReadWrite(bits: 4..<6)
        public var usart3sel: USART3SEL

        /// UART 4 clock source selection
        @ReadWrite(bits: 6..<8)
        public var uart4sel: UART4SEL

        /// UART 5 clock source selection
        @ReadWrite(bits: 8..<10)
        public var uart5sel: UART5SEL

        /// USART 6 clock source selection
        @ReadWrite(bits: 10..<12)
        public var usart6sel: USART6SEL

        /// UART 7 clock source selection
        @ReadWrite(bits: 12..<14)
        public var uart7sel: UART7SEL

        /// UART 8 clock source selection
        @ReadWrite(bits: 14..<16)
        public var uart8sel: UART8SEL

        /// I2C1 clock source selection
        @ReadWrite(bits: 16..<18, as: I2C1SELValues.self)
        public var i2c1sel: I2C1SEL

        /// I2C2 clock source selection
        @ReadWrite(bits: 18..<20)
        public var i2c2sel: I2C2SEL

        /// I2C3 clock source selection
        @ReadWrite(bits: 20..<22)
        public var i2c3sel: I2C3SEL

        /// I2C4 clock source selection
        @ReadWrite(bits: 22..<24)
        public var i2c4sel: I2C4SEL

        /// Low power timer 1 clock source selection
        @ReadWrite(bits: 24..<26, as: LPTIM1SELValues.self)
        public var lptim1sel: LPTIM1SEL

        /// HDMI-CEC clock source selection
        @ReadWrite(bits: 26..<27, as: CECSELValues.self)
        public var cecsel: CECSEL

        /// 48MHz clock source selection
        @ReadWrite(bits: 27..<28, as: CK48MSELValues.self)
        public var ck48msel: CK48MSEL

        /// SDMMC clock source selection
        @ReadWrite(bits: 28..<29, as: SDMMC1SELValues.self)
        public var sdmmc1sel: SDMMC1SEL
    }
}

extension RCC.CR {
    public struct CSSONValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Clock security system disabled (clock detector OFF)
        public static let Off = Self(rawValue: 0x0)

        /// Clock security system enable (clock detector ON if the HSE is ready, OFF if not)
        public static let On = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.CR {
    public struct HSEBYPValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// HSE crystal oscillator not bypassed
        public static let NotBypassed = Self(rawValue: 0x0)

        /// HSE crystal oscillator bypassed with external clock
        public static let Bypassed = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.CR {
    public struct HSIONValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Clock Off
        public static let Off = Self(rawValue: 0x0)

        /// Clock On
        public static let On = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.PLLCFGR {
    public struct PLLSRCValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// HSI clock selected as PLL and PLLI2S clock entry
        public static let HSI = Self(rawValue: 0x0)

        /// HSE oscillator clock selected as PLL and PLLI2S clock entry
        public static let HSE = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.PLLCFGR {
    public struct PLLPValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// PLLP=2
        public static let Div2 = Self(rawValue: 0x0)

        /// PLLP=4
        public static let Div4 = Self(rawValue: 0x1)

        /// PLLP=6
        public static let Div6 = Self(rawValue: 0x2)

        /// PLLP=8
        public static let Div8 = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.CFGR {
    public struct MCO2Values: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// System clock (SYSCLK) selected
        public static let SYSCLK = Self(rawValue: 0x0)

        /// PLLI2S clock selected
        public static let PLLI2S = Self(rawValue: 0x1)

        /// HSE oscillator clock selected
        public static let HSE = Self(rawValue: 0x2)

        /// PLL clock selected
        public static let PLL = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.CFGR {
    public struct MCO1PREValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 3

        /// No division
        public static let Div1 = Self(rawValue: 0x0)

        /// Division by 2
        public static let Div2 = Self(rawValue: 0x4)

        /// Division by 3
        public static let Div3 = Self(rawValue: 0x5)

        /// Division by 4
        public static let Div4 = Self(rawValue: 0x6)

        /// Division by 5
        public static let Div5 = Self(rawValue: 0x7)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.CFGR {
    public struct I2SSRCValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// PLLI2S clock used as I2S clock source
        public static let PLLI2S = Self(rawValue: 0x0)

        /// External clock mapped on the I2S_CKIN pin used as I2S clock source
        public static let CKIN = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.CFGR {
    public struct MCO1Values: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// HSI clock selected
        public static let HSI = Self(rawValue: 0x0)

        /// LSE oscillator selected
        public static let LSE = Self(rawValue: 0x1)

        /// HSE oscillator clock selected
        public static let HSE = Self(rawValue: 0x2)

        /// PLL clock selected
        public static let PLL = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.CFGR {
    public struct PPRE1Values: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 3

        /// HCLK not divided
        public static let Div1 = Self(rawValue: 0x0)

        /// HCLK divided by 2
        public static let Div2 = Self(rawValue: 0x4)

        /// HCLK divided by 4
        public static let Div4 = Self(rawValue: 0x5)

        /// HCLK divided by 8
        public static let Div8 = Self(rawValue: 0x6)

        /// HCLK divided by 16
        public static let Div16 = Self(rawValue: 0x7)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.CFGR {
    public struct HPREValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 4

        /// SYSCLK not divided
        public static let Div1 = Self(rawValue: 0x0)

        /// SYSCLK divided by 2
        public static let Div2 = Self(rawValue: 0x8)

        /// SYSCLK divided by 4
        public static let Div4 = Self(rawValue: 0x9)

        /// SYSCLK divided by 8
        public static let Div8 = Self(rawValue: 0xa)

        /// SYSCLK divided by 16
        public static let Div16 = Self(rawValue: 0xb)

        /// SYSCLK divided by 64
        public static let Div64 = Self(rawValue: 0xc)

        /// SYSCLK divided by 128
        public static let Div128 = Self(rawValue: 0xd)

        /// SYSCLK divided by 256
        public static let Div256 = Self(rawValue: 0xe)

        /// SYSCLK divided by 512
        public static let Div512 = Self(rawValue: 0xf)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.CFGR {
    public struct SWValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// HSI selected as system clock
        public static let HSI = Self(rawValue: 0x0)

        /// HSE selected as system clock
        public static let HSE = Self(rawValue: 0x1)

        /// PLL selected as system clock
        public static let PLL = Self(rawValue: 0x2)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.CIR {
    public struct LSIRDYIEValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Interrupt disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Interrupt enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.AHB1RSTR {
    public struct GPIOARSTValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Reset the selected module
        public static let Reset = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.AHB2RSTR {
    public struct DCMIRSTValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Reset the selected module
        public static let Reset = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.AHB3RSTR {
    public struct FMCRSTValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Reset the selected module
        public static let Reset = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.APB1RSTR {
    public struct TIM2RSTValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Reset the selected module
        public static let Reset = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.APB2RSTR {
    public struct TIM1RSTValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Reset the selected module
        public static let Reset = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.AHB1ENR {
    public struct GPIOAENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// The selected clock is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// The selected clock is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.AHB2ENR {
    public struct DCMIENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// The selected clock is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// The selected clock is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.AHB3ENR {
    public struct FMCENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// The selected clock is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// The selected clock is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.APB1ENR {
    public struct TIM2ENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// The selected clock is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// The selected clock is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.APB2ENR {
    public struct TIM1ENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// The selected clock is disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// The selected clock is enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.AHB1LPENR {
    public struct GPIOALPENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Selected module is disabled during Sleep mode
        public static let DisabledInSleep = Self(rawValue: 0x0)

        /// Selected module is enabled during Sleep mode
        public static let EnabledInSleep = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.AHB2LPENR {
    public struct DCMILPENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Selected module is disabled during Sleep mode
        public static let DisabledInSleep = Self(rawValue: 0x0)

        /// Selected module is enabled during Sleep mode
        public static let EnabledInSleep = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.AHB3LPENR {
    public struct FMCLPENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Selected module is disabled during Sleep mode
        public static let DisabledInSleep = Self(rawValue: 0x0)

        /// Selected module is enabled during Sleep mode
        public static let EnabledInSleep = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.APB1LPENR {
    public struct TIM2LPENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Selected module is disabled during Sleep mode
        public static let DisabledInSleep = Self(rawValue: 0x0)

        /// Selected module is enabled during Sleep mode
        public static let EnabledInSleep = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.APB2LPENR {
    public struct TIM1LPENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Selected module is disabled during Sleep mode
        public static let DisabledInSleep = Self(rawValue: 0x0)

        /// Selected module is enabled during Sleep mode
        public static let EnabledInSleep = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.BDCR {
    public struct BDRSTValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Reset not activated
        public static let Disabled = Self(rawValue: 0x0)

        /// Reset the entire RTC domain
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.BDCR {
    public struct RTCENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// RTC clock disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// RTC clock enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.BDCR {
    public struct LSEBYPValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// LSE crystal oscillator not bypassed
        public static let NotBypassed = Self(rawValue: 0x0)

        /// LSE crystal oscillator bypassed with external clock
        public static let Bypassed = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.BDCR {
    public struct LSEONValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// LSE oscillator Off
        public static let Off = Self(rawValue: 0x0)

        /// LSE oscillator On
        public static let On = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.BDCR {
    public struct LSEDRVValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// Low drive capacity
        public static let Low = Self(rawValue: 0x0)

        /// Medium-high drive capacity
        public static let MediumHigh = Self(rawValue: 0x1)

        /// Medium-low drive capacity
        public static let MediumLow = Self(rawValue: 0x2)

        /// High drive capacity
        public static let High = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.BDCR {
    public struct RTCSELValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// No clock
        public static let NoClock = Self(rawValue: 0x0)

        /// LSE oscillator clock used as RTC clock
        public static let LSE = Self(rawValue: 0x1)

        /// LSI oscillator clock used as RTC clock
        public static let LSI = Self(rawValue: 0x2)

        /// HSE oscillator clock divided by a prescaler used as RTC clock
        public static let HSE = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.CSR {
    public struct LSIONValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// LSI oscillator Off
        public static let Off = Self(rawValue: 0x0)

        /// LSI oscillator On
        public static let On = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.SSCGR {
    public struct SSCGENValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Spread spectrum modulation disabled
        public static let Disabled = Self(rawValue: 0x0)

        /// Spread spectrum modulation enabled
        public static let Enabled = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.SSCGR {
    public struct SPREADSELValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// Center spread
        public static let Center = Self(rawValue: 0x0)

        /// Down spread
        public static let Down = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.PLLI2SCFGR {
    public struct PLLI2SPValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// PLL*P=2
        public static let Div2 = Self(rawValue: 0x0)

        /// PLL*P=4
        public static let Div4 = Self(rawValue: 0x1)

        /// PLL*P=6
        public static let Div6 = Self(rawValue: 0x2)

        /// PLL*P=8
        public static let Div8 = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.PLLSAICFGR {
    public struct PLLSAIPValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// PLL*P=2
        public static let Div2 = Self(rawValue: 0x0)

        /// PLL*P=4
        public static let Div4 = Self(rawValue: 0x1)

        /// PLL*P=6
        public static let Div6 = Self(rawValue: 0x2)

        /// PLL*P=8
        public static let Div8 = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR1 {
    public struct PLLI2SDIVQValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 5

        /// PLLI2SDIVQ = /1
        public static let Div1 = Self(rawValue: 0x0)

        /// PLLI2SDIVQ = /2
        public static let Div2 = Self(rawValue: 0x1)

        /// PLLI2SDIVQ = /3
        public static let Div3 = Self(rawValue: 0x2)

        /// PLLI2SDIVQ = /4
        public static let Div4 = Self(rawValue: 0x3)

        /// PLLI2SDIVQ = /5
        public static let Div5 = Self(rawValue: 0x4)

        /// PLLI2SDIVQ = /6
        public static let Div6 = Self(rawValue: 0x5)

        /// PLLI2SDIVQ = /7
        public static let Div7 = Self(rawValue: 0x6)

        /// PLLI2SDIVQ = /8
        public static let Div8 = Self(rawValue: 0x7)

        /// PLLI2SDIVQ = /9
        public static let Div9 = Self(rawValue: 0x8)

        /// PLLI2SDIVQ = /10
        public static let Div10 = Self(rawValue: 0x9)

        /// PLLI2SDIVQ = /11
        public static let Div11 = Self(rawValue: 0xa)

        /// PLLI2SDIVQ = /12
        public static let Div12 = Self(rawValue: 0xb)

        /// PLLI2SDIVQ = /13
        public static let Div13 = Self(rawValue: 0xc)

        /// PLLI2SDIVQ = /14
        public static let Div14 = Self(rawValue: 0xd)

        /// PLLI2SDIVQ = /15
        public static let Div15 = Self(rawValue: 0xe)

        /// PLLI2SDIVQ = /16
        public static let Div16 = Self(rawValue: 0xf)

        /// PLLI2SDIVQ = /17
        public static let Div17 = Self(rawValue: 0x10)

        /// PLLI2SDIVQ = /18
        public static let Div18 = Self(rawValue: 0x11)

        /// PLLI2SDIVQ = /19
        public static let Div19 = Self(rawValue: 0x12)

        /// PLLI2SDIVQ = /20
        public static let Div20 = Self(rawValue: 0x13)

        /// PLLI2SDIVQ = /21
        public static let Div21 = Self(rawValue: 0x14)

        /// PLLI2SDIVQ = /22
        public static let Div22 = Self(rawValue: 0x15)

        /// PLLI2SDIVQ = /23
        public static let Div23 = Self(rawValue: 0x16)

        /// PLLI2SDIVQ = /24
        public static let Div24 = Self(rawValue: 0x17)

        /// PLLI2SDIVQ = /25
        public static let Div25 = Self(rawValue: 0x18)

        /// PLLI2SDIVQ = /26
        public static let Div26 = Self(rawValue: 0x19)

        /// PLLI2SDIVQ = /27
        public static let Div27 = Self(rawValue: 0x1a)

        /// PLLI2SDIVQ = /28
        public static let Div28 = Self(rawValue: 0x1b)

        /// PLLI2SDIVQ = /29
        public static let Div29 = Self(rawValue: 0x1c)

        /// PLLI2SDIVQ = /30
        public static let Div30 = Self(rawValue: 0x1d)

        /// PLLI2SDIVQ = /31
        public static let Div31 = Self(rawValue: 0x1e)

        /// PLLI2SDIVQ = /32
        public static let Div32 = Self(rawValue: 0x1f)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR1 {
    public struct PLLSAIDIVQValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 5

        /// PLLSAIDIVQ = /1
        public static let Div1 = Self(rawValue: 0x0)

        /// PLLSAIDIVQ = /2
        public static let Div2 = Self(rawValue: 0x1)

        /// PLLSAIDIVQ = /3
        public static let Div3 = Self(rawValue: 0x2)

        /// PLLSAIDIVQ = /4
        public static let Div4 = Self(rawValue: 0x3)

        /// PLLSAIDIVQ = /5
        public static let Div5 = Self(rawValue: 0x4)

        /// PLLSAIDIVQ = /6
        public static let Div6 = Self(rawValue: 0x5)

        /// PLLSAIDIVQ = /7
        public static let Div7 = Self(rawValue: 0x6)

        /// PLLSAIDIVQ = /8
        public static let Div8 = Self(rawValue: 0x7)

        /// PLLSAIDIVQ = /9
        public static let Div9 = Self(rawValue: 0x8)

        /// PLLSAIDIVQ = /10
        public static let Div10 = Self(rawValue: 0x9)

        /// PLLSAIDIVQ = /11
        public static let Div11 = Self(rawValue: 0xa)

        /// PLLSAIDIVQ = /12
        public static let Div12 = Self(rawValue: 0xb)

        /// PLLSAIDIVQ = /13
        public static let Div13 = Self(rawValue: 0xc)

        /// PLLSAIDIVQ = /14
        public static let Div14 = Self(rawValue: 0xd)

        /// PLLSAIDIVQ = /15
        public static let Div15 = Self(rawValue: 0xe)

        /// PLLSAIDIVQ = /16
        public static let Div16 = Self(rawValue: 0xf)

        /// PLLSAIDIVQ = /17
        public static let Div17 = Self(rawValue: 0x10)

        /// PLLSAIDIVQ = /18
        public static let Div18 = Self(rawValue: 0x11)

        /// PLLSAIDIVQ = /19
        public static let Div19 = Self(rawValue: 0x12)

        /// PLLSAIDIVQ = /20
        public static let Div20 = Self(rawValue: 0x13)

        /// PLLSAIDIVQ = /21
        public static let Div21 = Self(rawValue: 0x14)

        /// PLLSAIDIVQ = /22
        public static let Div22 = Self(rawValue: 0x15)

        /// PLLSAIDIVQ = /23
        public static let Div23 = Self(rawValue: 0x16)

        /// PLLSAIDIVQ = /24
        public static let Div24 = Self(rawValue: 0x17)

        /// PLLSAIDIVQ = /25
        public static let Div25 = Self(rawValue: 0x18)

        /// PLLSAIDIVQ = /26
        public static let Div26 = Self(rawValue: 0x19)

        /// PLLSAIDIVQ = /27
        public static let Div27 = Self(rawValue: 0x1a)

        /// PLLSAIDIVQ = /28
        public static let Div28 = Self(rawValue: 0x1b)

        /// PLLSAIDIVQ = /29
        public static let Div29 = Self(rawValue: 0x1c)

        /// PLLSAIDIVQ = /30
        public static let Div30 = Self(rawValue: 0x1d)

        /// PLLSAIDIVQ = /31
        public static let Div31 = Self(rawValue: 0x1e)

        /// PLLSAIDIVQ = /32
        public static let Div32 = Self(rawValue: 0x1f)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR1 {
    public struct PLLSAIDIVRValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// PLLSAIDIVR = /2
        public static let Div2 = Self(rawValue: 0x0)

        /// PLLSAIDIVR = /4
        public static let Div4 = Self(rawValue: 0x1)

        /// PLLSAIDIVR = /8
        public static let Div8 = Self(rawValue: 0x2)

        /// PLLSAIDIVR = /16
        public static let Div16 = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR1 {
    public struct SAI1SELValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// SAI1 clock frequency = f(PLLSAI_Q) / PLLSAIDIVQ
        public static let PLLSAI = Self(rawValue: 0x0)

        /// SAI1 clock frequency = f(PLLI2S_Q) / PLLI2SDIVQ
        public static let PLLI2S = Self(rawValue: 0x1)

        /// SAI1 clock frequency = Alternate function input frequency
        public static let AFIF = Self(rawValue: 0x2)

        /// SAI1 clock frequency = HSI or HSE
        public static let HSI_HSE = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR1 {
    public struct SAI2SELValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// SAI2 clock frequency = f(PLLSAI_Q) / PLLSAIDIVQ
        public static let PLLSAI = Self(rawValue: 0x0)

        /// SAI2 clock frequency = f(PLLI2S_Q) / PLLI2SDIVQ
        public static let PLLI2S = Self(rawValue: 0x1)

        /// SAI2 clock frequency = Alternate function input frequency
        public static let AFIF = Self(rawValue: 0x2)

        /// SAI2 clock frequency = HSI or HSE
        public static let HSI_HSE = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR1 {
    public struct TIMPREValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// If the APB prescaler is configured 1, TIMxCLK = PCLKx. Otherwise, TIMxCLK = 2xPCLKx
        public static let Mul1Or2 = Self(rawValue: 0x0)

        /// If the APB prescaler is configured 1, 2 or 4, TIMxCLK = HCLK. Otherwise, TIMxCLK = 4xPCLKx
        public static let Mul1Or4 = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR2 {
    public struct USART1SELValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// APB2 clock (PCLK2) is selected as USART clock
        public static let APB2 = Self(rawValue: 0x0)

        /// System clock is selected as USART clock
        public static let SYSCLK = Self(rawValue: 0x1)

        /// HSI clock is selected as USART clock
        public static let HSI = Self(rawValue: 0x2)

        /// LSE clock is selected as USART clock
        public static let LSE = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR2 {
    public struct USART2SELValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// APB1 clock (PCLK1) is selected as USART clock
        public static let APB1 = Self(rawValue: 0x0)

        /// System clock is selected as USART clock
        public static let SYSCLK = Self(rawValue: 0x1)

        /// HSI clock is selected as USART clock
        public static let HSI = Self(rawValue: 0x2)

        /// LSE clock is selected as USART clock
        public static let LSE = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR2 {
    public struct I2C1SELValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// APB clock selected as I2C clock
        public static let APB = Self(rawValue: 0x0)

        /// System clock selected as I2C clock
        public static let SYSCLK = Self(rawValue: 0x1)

        /// HSI clock selected as I2C clock
        public static let HSI = Self(rawValue: 0x2)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR2 {
    public struct LPTIM1SELValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 2

        /// APB1 clock (PCLK1) selected as LPTILM1 clock
        public static let APB1 = Self(rawValue: 0x0)

        /// LSI clock is selected as LPTILM1 clock
        public static let LSI = Self(rawValue: 0x1)

        /// HSI clock is selected as LPTILM1 clock
        public static let HSI = Self(rawValue: 0x2)

        /// LSE clock is selected as LPTILM1 clock
        public static let LSE = Self(rawValue: 0x3)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR2 {
    public struct CECSELValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// LSE clock is selected as HDMI-CEC clock
        public static let LSE = Self(rawValue: 0x0)

        /// HSI divided by 488 clock is selected as HDMI-CEC clock
        public static let HSI_Div488 = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR2 {
    public struct CK48MSELValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// 48MHz clock from PLL is selected
        public static let PLL = Self(rawValue: 0x0)

        /// 48MHz clock from PLLSAI is selected
        public static let PLLSAI = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RCC.DCKCFGR2 {
    public struct SDMMC1SELValues: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 1

        /// 48 MHz clock is selected as SD clock
        public static let CK48M = Self(rawValue: 0x0)

        /// System clock is selected as SD clock
        public static let SYSCLK = Self(rawValue: 0x1)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
