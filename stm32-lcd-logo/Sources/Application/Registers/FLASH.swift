// Generated by svd2swift.

import MMIO

/// FLASH
@RegisterBlock
struct FLASH {
  /// Flash access control register
  @RegisterBlock(offset: 0x0)
  var acr: Register<ACR>

  /// Flash key register
  @RegisterBlock(offset: 0x4)
  var keyr: Register<KEYR>

  /// Flash option key register
  @RegisterBlock(offset: 0x8)
  var optkeyr: Register<OPTKEYR>

  /// Status register
  @RegisterBlock(offset: 0xc)
  var sr: Register<SR>

  /// Control register
  @RegisterBlock(offset: 0x10)
  var cr: Register<CR>

  /// Flash option control register
  @RegisterBlock(offset: 0x14)
  var optcr: Register<OPTCR>

  /// Flash option control register 1
  @RegisterBlock(offset: 0x18)
  var optcr1: Register<OPTCR1>
}

extension FLASH {
  /// Flash access control register
  @Register(bitWidth: 32)
  struct ACR {
    /// Latency
    @ReadWrite(bits: 0..<4, as: LATENCYValues.self)
    var latency: LATENCY

    /// Prefetch enable
    @ReadWrite(bits: 8..<9, as: PRFTENValues.self)
    var prften: PRFTEN

    /// ART Accelerator Enable
    @ReadWrite(bits: 9..<10, as: ARTENValues.self)
    var arten: ARTEN

    /// ART Accelerator reset
    @ReadWrite(bits: 11..<12, as: ARTRSTValues.self)
    var artrst: ARTRST
  }

  /// Flash key register
  @Register(bitWidth: 32)
  struct KEYR {
    /// FPEC key
    @WriteOnly(bits: 0..<32)
    var key: KEY
  }

  /// Flash option key register
  @Register(bitWidth: 32)
  struct OPTKEYR {
    /// Option byte key
    @WriteOnly(bits: 0..<32)
    var optkeyr_field: OPTKEYR_FIELD
  }

  /// Status register
  @Register(bitWidth: 32)
  struct SR {
    /// End of operation
    @ReadWrite(bits: 0..<1)
    var eop: EOP

    /// Operation error
    @ReadWrite(bits: 1..<2)
    var operr: OPERR

    /// Write protection error
    @ReadWrite(bits: 4..<5)
    var wrperr: WRPERR

    /// Programming alignment error
    @ReadWrite(bits: 5..<6)
    var pgaerr: PGAERR

    /// Programming parallelism error
    @ReadWrite(bits: 6..<7)
    var pgperr: PGPERR

    /// Programming sequence error
    @ReadWrite(bits: 7..<8)
    var erserr: ERSERR

    /// Busy
    @ReadOnly(bits: 16..<17)
    var bsy: BSY
  }

  /// Control register
  @Register(bitWidth: 32)
  struct CR {
    /// Programming
    @ReadWrite(bits: 0..<1, as: PGValues.self)
    var pg: PG

    /// Sector Erase
    @ReadWrite(bits: 1..<2, as: SERValues.self)
    var ser: SER

    /// Mass Erase of sectors 0 to 11
    @ReadWrite(bits: 2..<3, as: MERValues.self)
    var mer: MER

    /// Sector number
    @ReadWrite(bits: 3..<7)
    var snb: SNB

    /// Program size
    @ReadWrite(bits: 8..<10, as: PSIZEValues.self)
    var psize: PSIZE

    /// Start
    @ReadWrite(bits: 16..<17, as: STRTValues.self)
    var strt: STRT

    /// End of operation interrupt enable
    @ReadWrite(bits: 24..<25, as: EOPIEValues.self)
    var eopie: EOPIE

    /// Error interrupt enable
    @ReadWrite(bits: 25..<26, as: ERRIEValues.self)
    var errie: ERRIE

    /// Lock
    @ReadWrite(bits: 31..<32, as: LOCKValues.self)
    var lock: LOCK
  }

  /// Flash option control register
  @Register(bitWidth: 32)
  struct OPTCR {
    /// Option lock
    @ReadWrite(bits: 0..<1)
    var optlock: OPTLOCK

    /// Option start
    @ReadWrite(bits: 1..<2)
    var optstrt: OPTSTRT

    /// BOR reset Level
    @ReadWrite(bits: 2..<4)
    var bor_lev: BOR_LEV

    /// User option bytes
    @ReadWrite(bits: 4..<5)
    var wwdg_sw: WWDG_SW

    /// User option bytes
    @ReadWrite(bits: 5..<6)
    var iwdg_sw: IWDG_SW

    /// User option bytes
    @ReadWrite(bits: 6..<7)
    var nrst_stop: nRST_STOP

    /// User option bytes
    @ReadWrite(bits: 7..<8)
    var nrst_stdby: nRST_STDBY

    /// Read protect
    @ReadWrite(bits: 8..<16)
    var rdp: RDP

    /// Not write protect
    @ReadWrite(bits: 16..<24)
    var nwrp: nWRP

    /// Independent watchdog counter freeze in standby mode
    @ReadWrite(bits: 30..<31)
    var iwdg_stdby: IWDG_STDBY

    /// Independent watchdog counter freeze in Stop mode
    @ReadWrite(bits: 31..<32)
    var iwdg_stop: IWDG_STOP
  }

  /// Flash option control register 1
  @Register(bitWidth: 32)
  struct OPTCR1 {
    /// Boot base address when Boot pin =0
    @ReadWrite(bits: 0..<16)
    var boot_add0: BOOT_ADD0

    /// Boot base address when Boot pin =1
    @ReadWrite(bits: 16..<32)
    var boot_add1: BOOT_ADD1
  }
}

extension FLASH.ACR {
  struct LATENCYValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 4

    /// 0 wait states
    static let WS0 = Self(rawValue: 0x0)

    /// 1 wait states
    static let WS1 = Self(rawValue: 0x1)

    /// 2 wait states
    static let WS2 = Self(rawValue: 0x2)

    /// 3 wait states
    static let WS3 = Self(rawValue: 0x3)

    /// 4 wait states
    static let WS4 = Self(rawValue: 0x4)

    /// 5 wait states
    static let WS5 = Self(rawValue: 0x5)

    /// 6 wait states
    static let WS6 = Self(rawValue: 0x6)

    /// 7 wait states
    static let WS7 = Self(rawValue: 0x7)

    /// 8 wait states
    static let WS8 = Self(rawValue: 0x8)

    /// 9 wait states
    static let WS9 = Self(rawValue: 0x9)

    /// 10 wait states
    static let WS10 = Self(rawValue: 0xa)

    /// 11 wait states
    static let WS11 = Self(rawValue: 0xb)

    /// 12 wait states
    static let WS12 = Self(rawValue: 0xc)

    /// 13 wait states
    static let WS13 = Self(rawValue: 0xd)

    /// 14 wait states
    static let WS14 = Self(rawValue: 0xe)

    /// 15 wait states
    static let WS15 = Self(rawValue: 0xf)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.ACR {
  struct PRFTENValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Prefetch is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Prefetch is enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.ACR {
  struct ARTENValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// ART Accelerator is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// ART Accelerator is enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.ACR {
  struct ARTRSTValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Accelerator is not reset
    static let NotReset = Self(rawValue: 0x0)

    /// Accelerator is reset
    static let Reset = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  struct PGValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Flash programming activated
    static let Program = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  struct SERValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Erase activated for selected sector
    static let SectorErase = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  struct MERValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Erase activated for all user sectors
    static let MassErase = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  struct PSIZEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 2

    /// Program x8
    static let PSIZE8 = Self(rawValue: 0x0)

    /// Program x16
    static let PSIZE16 = Self(rawValue: 0x1)

    /// Program x32
    static let PSIZE32 = Self(rawValue: 0x2)

    /// Program x64
    static let PSIZE64 = Self(rawValue: 0x3)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  struct STRTValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Trigger an erase operation
    static let Start = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  struct EOPIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// End of operation interrupt disabled
    static let Disabled = Self(rawValue: 0x0)

    /// End of operation interrupt enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  struct ERRIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Error interrupt generation disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Error interrupt generation enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  struct LOCKValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// FLASH_CR register is unlocked
    static let Unlocked = Self(rawValue: 0x0)

    /// FLASH_CR register is locked
    static let Locked = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}
