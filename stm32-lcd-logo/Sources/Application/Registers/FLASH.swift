// Generated by svd2swift.

import MMIO

/// FLASH
@RegisterBlock
struct FLASH {
    /// Flash access control register
    @RegisterBlock(offset: 0x0)
    var acr: Register<ACR>

    /// Flash key register
    @RegisterBlock(offset: 0x4)
    var keyr: Register<KEYR>

    /// Flash option key register
    @RegisterBlock(offset: 0x8)
    var optkeyr: Register<OPTKEYR>

    /// Status register
    @RegisterBlock(offset: 0xc)
    var sr: Register<SR>

    /// Control register
    @RegisterBlock(offset: 0x10)
    var cr: Register<CR>

    /// Flash option control register
    @RegisterBlock(offset: 0x14)
    var optcr: Register<OPTCR>

    /// Flash option control register 1
    @RegisterBlock(offset: 0x18)
    var optcr1: Register<OPTCR1>
}

extension FLASH {
    /// Flash access control register
    @Register(bitWidth: 32)
    struct ACR {
        /// Latency
        @ReadWrite(bits: 0..<4, as: LATENCYValues.self)
        var latency: LATENCY

        /// Prefetch enable
        @ReadWrite(bits: 8..<9, as: PRFTENValues.self)
        var prften: PRFTEN

        /// ART Accelerator Enable
        @ReadWrite(bits: 9..<10, as: ARTENValues.self)
        var arten: ARTEN

        /// ART Accelerator reset
        @ReadWrite(bits: 11..<12, as: ARTRSTValues.self)
        var artrst: ARTRST
    }

    /// Flash key register
    @Register(bitWidth: 32)
    struct KEYR {
        /// FPEC key
        @WriteOnly(bits: 0..<32)
        var key: KEY
    }

    /// Flash option key register
    @Register(bitWidth: 32)
    struct OPTKEYR {
        /// Option byte key
        @WriteOnly(bits: 0..<32)
        var optkeyr_field: OPTKEYR_FIELD
    }

    /// Status register
    @Register(bitWidth: 32)
    struct SR {
        /// End of operation
        @ReadWrite(bits: 0..<1)
        var eop: EOP

        /// Operation error
        @ReadWrite(bits: 1..<2)
        var operr: OPERR

        /// Write protection error
        @ReadWrite(bits: 4..<5)
        var wrperr: WRPERR

        /// Programming alignment error
        @ReadWrite(bits: 5..<6)
        var pgaerr: PGAERR

        /// Programming parallelism error
        @ReadWrite(bits: 6..<7)
        var pgperr: PGPERR

        /// Programming sequence error
        @ReadWrite(bits: 7..<8)
        var erserr: ERSERR

        /// Busy
        @ReadOnly(bits: 16..<17)
        var bsy: BSY
    }

    /// Control register
    @Register(bitWidth: 32)
    struct CR {
        /// Programming
        @ReadWrite(bits: 0..<1, as: PGValues.self)
        var pg: PG

        /// Sector Erase
        @ReadWrite(bits: 1..<2, as: SERValues.self)
        var ser: SER

        /// Mass Erase of sectors 0 to 11
        @ReadWrite(bits: 2..<3, as: MERValues.self)
        var mer: MER

        /// Sector number
        @ReadWrite(bits: 3..<7)
        var snb: SNB

        /// Program size
        @ReadWrite(bits: 8..<10, as: PSIZEValues.self)
        var psize: PSIZE

        /// Start
        @ReadWrite(bits: 16..<17, as: STRTValues.self)
        var strt: STRT

        /// End of operation interrupt enable
        @ReadWrite(bits: 24..<25, as: EOPIEValues.self)
        var eopie: EOPIE

        /// Error interrupt enable
        @ReadWrite(bits: 25..<26, as: ERRIEValues.self)
        var errie: ERRIE

        /// Lock
        @ReadWrite(bits: 31..<32, as: LOCKValues.self)
        var lock: LOCK
    }

    /// Flash option control register
    @Register(bitWidth: 32)
    struct OPTCR {
        /// Option lock
        @ReadWrite(bits: 0..<1)
        var optlock: OPTLOCK

        /// Option start
        @ReadWrite(bits: 1..<2)
        var optstrt: OPTSTRT

        /// BOR reset Level
        @ReadWrite(bits: 2..<4)
        var bor_lev: BOR_LEV

        /// User option bytes
        @ReadWrite(bits: 4..<5)
        var wwdg_sw: WWDG_SW

        /// User option bytes
        @ReadWrite(bits: 5..<6)
        var iwdg_sw: IWDG_SW

        /// User option bytes
        @ReadWrite(bits: 6..<7)
        var nrst_stop: nRST_STOP

        /// User option bytes
        @ReadWrite(bits: 7..<8)
        var nrst_stdby: nRST_STDBY

        /// Read protect
        @ReadWrite(bits: 8..<16)
        var rdp: RDP

        /// Not write protect
        @ReadWrite(bits: 16..<24)
        var nwrp: nWRP

        /// Independent watchdog counter freeze in standby mode
        @ReadWrite(bits: 30..<31)
        var iwdg_stdby: IWDG_STDBY

        /// Independent watchdog counter freeze in Stop mode
        @ReadWrite(bits: 31..<32)
        var iwdg_stop: IWDG_STOP
    }

    /// Flash option control register 1
    @Register(bitWidth: 32)
    struct OPTCR1 {
        /// Boot base address when Boot pin =0
        @ReadWrite(bits: 0..<16)
        var boot_add0: BOOT_ADD0

        /// Boot base address when Boot pin =1
        @ReadWrite(bits: 16..<32)
        var boot_add1: BOOT_ADD1
    }
}

extension FLASH.ACR {
    struct LATENCYValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 4

        /// 0 wait states
        static let WS0 = Self(rawValue: 0x0)

        /// 1 wait states
        static let WS1 = Self(rawValue: 0x1)

        /// 2 wait states
        static let WS2 = Self(rawValue: 0x2)

        /// 3 wait states
        static let WS3 = Self(rawValue: 0x3)

        /// 4 wait states
        static let WS4 = Self(rawValue: 0x4)

        /// 5 wait states
        static let WS5 = Self(rawValue: 0x5)

        /// 6 wait states
        static let WS6 = Self(rawValue: 0x6)

        /// 7 wait states
        static let WS7 = Self(rawValue: 0x7)

        /// 8 wait states
        static let WS8 = Self(rawValue: 0x8)

        /// 9 wait states
        static let WS9 = Self(rawValue: 0x9)

        /// 10 wait states
        static let WS10 = Self(rawValue: 0xa)

        /// 11 wait states
        static let WS11 = Self(rawValue: 0xb)

        /// 12 wait states
        static let WS12 = Self(rawValue: 0xc)

        /// 13 wait states
        static let WS13 = Self(rawValue: 0xd)

        /// 14 wait states
        static let WS14 = Self(rawValue: 0xe)

        /// 15 wait states
        static let WS15 = Self(rawValue: 0xf)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.ACR {
    struct PRFTENValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Prefetch is disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Prefetch is enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.ACR {
    struct ARTENValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// ART Accelerator is disabled
        static let Disabled = Self(rawValue: 0x0)

        /// ART Accelerator is enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.ACR {
    struct ARTRSTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Accelerator is not reset
        static let NotReset = Self(rawValue: 0x0)

        /// Accelerator is reset
        static let Reset = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    struct PGValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Flash programming activated
        static let Program = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    struct SERValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Erase activated for selected sector
        static let SectorErase = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    struct MERValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Erase activated for all user sectors
        static let MassErase = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    struct PSIZEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Program x8
        static let PSIZE8 = Self(rawValue: 0x0)

        /// Program x16
        static let PSIZE16 = Self(rawValue: 0x1)

        /// Program x32
        static let PSIZE32 = Self(rawValue: 0x2)

        /// Program x64
        static let PSIZE64 = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    struct STRTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger an erase operation
        static let Start = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    struct EOPIEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// End of operation interrupt disabled
        static let Disabled = Self(rawValue: 0x0)

        /// End of operation interrupt enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    struct ERRIEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Error interrupt generation disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Error interrupt generation enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FLASH.CR {
    struct LOCKValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// FLASH_CR register is unlocked
        static let Unlocked = Self(rawValue: 0x0)

        /// FLASH_CR register is locked
        static let Locked = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
