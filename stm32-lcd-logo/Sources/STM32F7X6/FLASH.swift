// Generated by svd2swift.

import MMIO

/// FLASH
@RegisterBlock
public struct FLASH {
  /// Flash access control register
  @RegisterBlock(offset: 0x0)
  public var acr: Register<ACR>

  /// Flash key register
  @RegisterBlock(offset: 0x4)
  public var keyr: Register<KEYR>

  /// Flash option key register
  @RegisterBlock(offset: 0x8)
  public var optkeyr: Register<OPTKEYR>

  /// Status register
  @RegisterBlock(offset: 0xc)
  public var sr: Register<SR>

  /// Control register
  @RegisterBlock(offset: 0x10)
  public var cr: Register<CR>

  /// Flash option control register
  @RegisterBlock(offset: 0x14)
  public var optcr: Register<OPTCR>

  /// Flash option control register 1
  @RegisterBlock(offset: 0x18)
  public var optcr1: Register<OPTCR1>
}

extension FLASH {
  /// Flash access control register
  @Register(bitWidth: 32)
  public struct ACR {
    /// Latency
    @ReadWrite(bits: 0..<4, as: LATENCYValues.self)
    public var latency: LATENCY

    /// Prefetch enable
    @ReadWrite(bits: 8..<9, as: PRFTENValues.self)
    public var prften: PRFTEN

    /// ART Accelerator Enable
    @ReadWrite(bits: 9..<10, as: ARTENValues.self)
    public var arten: ARTEN

    /// ART Accelerator reset
    @ReadWrite(bits: 11..<12, as: ARTRSTValues.self)
    public var artrst: ARTRST
  }

  /// Flash key register
  @Register(bitWidth: 32)
  public struct KEYR {
    /// FPEC key
    @WriteOnly(bits: 0..<32)
    public var key: KEY
  }

  /// Flash option key register
  @Register(bitWidth: 32)
  public struct OPTKEYR {
    /// Option byte key
    @WriteOnly(bits: 0..<32)
    public var optkeyr_field: OPTKEYR_FIELD
  }

  /// Status register
  @Register(bitWidth: 32)
  public struct SR {
    /// End of operation
    @ReadWrite(bits: 0..<1)
    public var eop: EOP

    /// Operation error
    @ReadWrite(bits: 1..<2)
    public var operr: OPERR

    /// Write protection error
    @ReadWrite(bits: 4..<5)
    public var wrperr: WRPERR

    /// Programming alignment error
    @ReadWrite(bits: 5..<6)
    public var pgaerr: PGAERR

    /// Programming parallelism error
    @ReadWrite(bits: 6..<7)
    public var pgperr: PGPERR

    /// Programming sequence error
    @ReadWrite(bits: 7..<8)
    public var erserr: ERSERR

    /// Busy
    @ReadOnly(bits: 16..<17)
    public var bsy: BSY
  }

  /// Control register
  @Register(bitWidth: 32)
  public struct CR {
    /// Programming
    @ReadWrite(bits: 0..<1, as: PGValues.self)
    public var pg: PG

    /// Sector Erase
    @ReadWrite(bits: 1..<2, as: SERValues.self)
    public var ser: SER

    /// Mass Erase of sectors 0 to 11
    @ReadWrite(bits: 2..<3, as: MERValues.self)
    public var mer: MER

    /// Sector number
    @ReadWrite(bits: 3..<7)
    public var snb: SNB

    /// Program size
    @ReadWrite(bits: 8..<10, as: PSIZEValues.self)
    public var psize: PSIZE

    /// Start
    @ReadWrite(bits: 16..<17, as: STRTValues.self)
    public var strt: STRT

    /// End of operation interrupt enable
    @ReadWrite(bits: 24..<25, as: EOPIEValues.self)
    public var eopie: EOPIE

    /// Error interrupt enable
    @ReadWrite(bits: 25..<26, as: ERRIEValues.self)
    public var errie: ERRIE

    /// Lock
    @ReadWrite(bits: 31..<32, as: LOCKValues.self)
    public var lock: LOCK
  }

  /// Flash option control register
  @Register(bitWidth: 32)
  public struct OPTCR {
    /// Option lock
    @ReadWrite(bits: 0..<1)
    public var optlock: OPTLOCK

    /// Option start
    @ReadWrite(bits: 1..<2)
    public var optstrt: OPTSTRT

    /// BOR reset Level
    @ReadWrite(bits: 2..<4)
    public var bor_lev: BOR_LEV

    /// User option bytes
    @ReadWrite(bits: 4..<5)
    public var wwdg_sw: WWDG_SW

    /// User option bytes
    @ReadWrite(bits: 5..<6)
    public var iwdg_sw: IWDG_SW

    /// User option bytes
    @ReadWrite(bits: 6..<7)
    public var nrst_stop: nRST_STOP

    /// User option bytes
    @ReadWrite(bits: 7..<8)
    public var nrst_stdby: nRST_STDBY

    /// Read protect
    @ReadWrite(bits: 8..<16)
    public var rdp: RDP

    /// Not write protect
    @ReadWrite(bits: 16..<24)
    public var nwrp: nWRP

    /// Independent watchdog counter freeze in standby mode
    @ReadWrite(bits: 30..<31)
    public var iwdg_stdby: IWDG_STDBY

    /// Independent watchdog counter freeze in Stop mode
    @ReadWrite(bits: 31..<32)
    public var iwdg_stop: IWDG_STOP
  }

  /// Flash option control register 1
  @Register(bitWidth: 32)
  public struct OPTCR1 {
    /// Boot base address when Boot pin =0
    @ReadWrite(bits: 0..<16)
    public var boot_add0: BOOT_ADD0

    /// Boot base address when Boot pin =1
    @ReadWrite(bits: 16..<32)
    public var boot_add1: BOOT_ADD1
  }
}

extension FLASH.ACR {
  public struct LATENCYValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 4

    /// 0 wait states
    public static let WS0 = Self(rawValue: 0x0)

    /// 1 wait states
    public static let WS1 = Self(rawValue: 0x1)

    /// 2 wait states
    public static let WS2 = Self(rawValue: 0x2)

    /// 3 wait states
    public static let WS3 = Self(rawValue: 0x3)

    /// 4 wait states
    public static let WS4 = Self(rawValue: 0x4)

    /// 5 wait states
    public static let WS5 = Self(rawValue: 0x5)

    /// 6 wait states
    public static let WS6 = Self(rawValue: 0x6)

    /// 7 wait states
    public static let WS7 = Self(rawValue: 0x7)

    /// 8 wait states
    public static let WS8 = Self(rawValue: 0x8)

    /// 9 wait states
    public static let WS9 = Self(rawValue: 0x9)

    /// 10 wait states
    public static let WS10 = Self(rawValue: 0xa)

    /// 11 wait states
    public static let WS11 = Self(rawValue: 0xb)

    /// 12 wait states
    public static let WS12 = Self(rawValue: 0xc)

    /// 13 wait states
    public static let WS13 = Self(rawValue: 0xd)

    /// 14 wait states
    public static let WS14 = Self(rawValue: 0xe)

    /// 15 wait states
    public static let WS15 = Self(rawValue: 0xf)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.ACR {
  public struct PRFTENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Prefetch is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Prefetch is enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.ACR {
  public struct ARTENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// ART Accelerator is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// ART Accelerator is enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.ACR {
  public struct ARTRSTValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Accelerator is not reset
    public static let NotReset = Self(rawValue: 0x0)

    /// Accelerator is reset
    public static let Reset = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  public struct PGValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Flash programming activated
    public static let Program = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  public struct SERValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Erase activated for selected sector
    public static let SectorErase = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  public struct MERValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Erase activated for all user sectors
    public static let MassErase = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  public struct PSIZEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// Program x8
    public static let PSIZE8 = Self(rawValue: 0x0)

    /// Program x16
    public static let PSIZE16 = Self(rawValue: 0x1)

    /// Program x32
    public static let PSIZE32 = Self(rawValue: 0x2)

    /// Program x64
    public static let PSIZE64 = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  public struct STRTValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Trigger an erase operation
    public static let Start = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  public struct EOPIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// End of operation interrupt disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// End of operation interrupt enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  public struct ERRIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Error interrupt generation disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Error interrupt generation enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension FLASH.CR {
  public struct LOCKValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// FLASH_CR register is unlocked
    public static let Unlocked = Self(rawValue: 0x0)

    /// FLASH_CR register is locked
    public static let Locked = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}
