// Generated by svd2swift.

import MMIO

/// Universal synchronous asynchronous receiver transmitter
@RegisterBlock
struct USART1 {
  /// Control register 1
  @RegisterBlock(offset: 0x0)
  var cr1: Register<CR1>

  /// Control register 2
  @RegisterBlock(offset: 0x4)
  var cr2: Register<CR2>

  /// Control register 3
  @RegisterBlock(offset: 0x8)
  var cr3: Register<CR3>

  /// Baud rate register
  @RegisterBlock(offset: 0xc)
  var brr: Register<BRR>

  /// Guard time and prescaler register
  @RegisterBlock(offset: 0x10)
  var gtpr: Register<GTPR>

  /// Receiver timeout register
  @RegisterBlock(offset: 0x14)
  var rtor: Register<RTOR>

  /// Request register
  @RegisterBlock(offset: 0x18)
  var rqr: Register<RQR>

  /// Interrupt & status register
  @RegisterBlock(offset: 0x1c)
  var isr: Register<ISR>

  /// Interrupt flag clear register
  @RegisterBlock(offset: 0x20)
  var icr: Register<ICR>

  /// Receive data register
  @RegisterBlock(offset: 0x24)
  var rdr: Register<RDR>

  /// Transmit data register
  @RegisterBlock(offset: 0x28)
  var tdr: Register<TDR>
}

extension USART1 {
  /// Control register 1
  @Register(bitWidth: 32)
  struct CR1 {
    /// Word length
    @ReadWrite(bits: 28..<29, as: M1Values.self)
    var m1: M1

    /// End of Block interrupt enable
    @ReadWrite(bits: 27..<28, as: EOBIEValues.self)
    var eobie: EOBIE

    /// Receiver timeout interrupt enable
    @ReadWrite(bits: 26..<27, as: RTOIEValues.self)
    var rtoie: RTOIE

    /// Oversampling mode
    @ReadWrite(bits: 15..<16, as: OVER8Values.self)
    var over8: OVER8

    /// Character match interrupt enable
    @ReadWrite(bits: 14..<15, as: CMIEValues.self)
    var cmie: CMIE

    /// Mute mode enable
    @ReadWrite(bits: 13..<14, as: MMEValues.self)
    var mme: MME

    /// Word length
    @ReadWrite(bits: 12..<13, as: M0Values.self)
    var m0: M0

    /// Receiver wakeup method
    @ReadWrite(bits: 11..<12, as: WAKEValues.self)
    var wake: WAKE

    /// Parity control enable
    @ReadWrite(bits: 10..<11, as: PCEValues.self)
    var pce: PCE

    /// Parity selection
    @ReadWrite(bits: 9..<10, as: PSValues.self)
    var ps: PS

    /// PE interrupt enable
    @ReadWrite(bits: 8..<9, as: PEIEValues.self)
    var peie: PEIE

    /// interrupt enable
    @ReadWrite(bits: 7..<8, as: TXEIEValues.self)
    var txeie: TXEIE

    /// Transmission complete interrupt enable
    @ReadWrite(bits: 6..<7, as: TCIEValues.self)
    var tcie: TCIE

    /// RXNE interrupt enable
    @ReadWrite(bits: 5..<6, as: RXNEIEValues.self)
    var rxneie: RXNEIE

    /// IDLE interrupt enable
    @ReadWrite(bits: 4..<5, as: IDLEIEValues.self)
    var idleie: IDLEIE

    /// Transmitter enable
    @ReadWrite(bits: 3..<4, as: TEValues.self)
    var te: TE

    /// Receiver enable
    @ReadWrite(bits: 2..<3, as: REValues.self)
    var re: RE

    /// USART enable in Stop mode
    @ReadWrite(bits: 1..<2, as: UESMValues.self)
    var uesm: UESM

    /// USART enable
    @ReadWrite(bits: 0..<1, as: UEValues.self)
    var ue: UE

    /// Driver Enable assertion time
    @ReadWrite(bits: 21..<26)
    var deat: DEAT

    /// Driver Enable de-assertion time
    @ReadWrite(bits: 16..<21)
    var dedt: DEDT
  }

  /// Control register 2
  @Register(bitWidth: 32)
  struct CR2 {
    /// Receiver timeout enable
    @ReadWrite(bits: 23..<24, as: RTOENValues.self)
    var rtoen: RTOEN

    /// Auto baud rate enable
    @ReadWrite(bits: 20..<21, as: ABRENValues.self)
    var abren: ABREN

    /// Most significant bit first
    @ReadWrite(bits: 19..<20, as: MSBFIRSTValues.self)
    var msbfirst: MSBFIRST

    /// Binary data inversion
    @ReadWrite(bits: 18..<19, as: DATAINVValues.self)
    var datainv: DATAINV

    /// TX pin active level inversion
    @ReadWrite(bits: 17..<18, as: TXINVValues.self)
    var txinv: TXINV

    /// RX pin active level inversion
    @ReadWrite(bits: 16..<17, as: RXINVValues.self)
    var rxinv: RXINV

    /// Swap TX/RX pins
    @ReadWrite(bits: 15..<16, as: SWAPValues.self)
    var swap: SWAP

    /// LIN mode enable
    @ReadWrite(bits: 14..<15, as: LINENValues.self)
    var linen: LINEN

    /// STOP bits
    @ReadWrite(bits: 12..<14, as: STOPValues.self)
    var stop: STOP

    /// Clock enable
    @ReadWrite(bits: 11..<12, as: CLKENValues.self)
    var clken: CLKEN

    /// Clock polarity
    @ReadWrite(bits: 10..<11, as: CPOLValues.self)
    var cpol: CPOL

    /// Clock phase
    @ReadWrite(bits: 9..<10, as: CPHAValues.self)
    var cpha: CPHA

    /// Last bit clock pulse
    @ReadWrite(bits: 8..<9, as: LBCLValues.self)
    var lbcl: LBCL

    /// LIN break detection interrupt enable
    @ReadWrite(bits: 6..<7, as: LBDIEValues.self)
    var lbdie: LBDIE

    /// LIN break detection length
    @ReadWrite(bits: 5..<6, as: LBDLValues.self)
    var lbdl: LBDL

    /// 7-bit Address Detection/4-bit Address Detection
    @ReadWrite(bits: 4..<5, as: ADDM7Values.self)
    var addm7: ADDM7

    /// Auto baud rate mode
    @ReadWrite(bits: 21..<23, as: ABRMODValues.self)
    var abrmod: ABRMOD

    /// Address of the USART node
    @ReadWrite(bits: 24..<32)
    var add: ADD
  }

  /// Control register 3
  @Register(bitWidth: 32)
  struct CR3 {
    /// Wakeup from Stop mode interrupt enable
    @ReadWrite(bits: 22..<23, as: WUFIEValues.self)
    var wufie: WUFIE

    /// Wakeup from Stop mode interrupt flag selection
    @ReadWrite(bits: 20..<22, as: WUSValues.self)
    var wus: WUS

    /// Smartcard auto-retry count
    @ReadWrite(bits: 17..<20)
    var scarcnt: SCARCNT

    /// Driver enable polarity selection
    @ReadWrite(bits: 15..<16, as: DEPValues.self)
    var dep: DEP

    /// Driver enable mode
    @ReadWrite(bits: 14..<15, as: DEMValues.self)
    var dem: DEM

    /// DMA Disable on Reception Error
    @ReadWrite(bits: 13..<14, as: DDREValues.self)
    var ddre: DDRE

    /// Overrun Disable
    @ReadWrite(bits: 12..<13, as: OVRDISValues.self)
    var ovrdis: OVRDIS

    /// One sample bit method enable
    @ReadWrite(bits: 11..<12, as: ONEBITValues.self)
    var onebit: ONEBIT

    /// CTS interrupt enable
    @ReadWrite(bits: 10..<11, as: CTSIEValues.self)
    var ctsie: CTSIE

    /// CTS enable
    @ReadWrite(bits: 9..<10, as: CTSEValues.self)
    var ctse: CTSE

    /// RTS enable
    @ReadWrite(bits: 8..<9, as: RTSEValues.self)
    var rtse: RTSE

    /// DMA enable transmitter
    @ReadWrite(bits: 7..<8, as: DMATValues.self)
    var dmat: DMAT

    /// DMA enable receiver
    @ReadWrite(bits: 6..<7, as: DMARValues.self)
    var dmar: DMAR

    /// Smartcard mode enable
    @ReadWrite(bits: 5..<6, as: SCENValues.self)
    var scen: SCEN

    /// Smartcard NACK enable
    @ReadWrite(bits: 4..<5, as: NACKValues.self)
    var nack: NACK

    /// Half-duplex selection
    @ReadWrite(bits: 3..<4, as: HDSELValues.self)
    var hdsel: HDSEL

    /// Ir low-power
    @ReadWrite(bits: 2..<3, as: IRLPValues.self)
    var irlp: IRLP

    /// Ir mode enable
    @ReadWrite(bits: 1..<2, as: IRENValues.self)
    var iren: IREN

    /// Error interrupt enable
    @ReadWrite(bits: 0..<1, as: EIEValues.self)
    var eie: EIE
  }

  /// Baud rate register
  @Register(bitWidth: 32)
  struct BRR {
    /// DIV_Mantissa
    @ReadWrite(bits: 0..<16)
    var brr_field: BRR_FIELD
  }

  /// Guard time and prescaler register
  @Register(bitWidth: 32)
  struct GTPR {
    /// Guard time value
    @ReadWrite(bits: 8..<16)
    var gt: GT

    /// Prescaler value
    @ReadWrite(bits: 0..<8)
    var psc: PSC
  }

  /// Receiver timeout register
  @Register(bitWidth: 32)
  struct RTOR {
    /// Block Length
    @ReadWrite(bits: 24..<32)
    var blen: BLEN

    /// Receiver timeout value
    @ReadWrite(bits: 0..<24)
    var rto: RTO
  }

  /// Request register
  @Register(bitWidth: 32)
  struct RQR {
    /// Transmit data flush request
    @WriteOnly(bits: 4..<5)
    var txfrq: TXFRQ

    /// Receive data flush request
    @WriteOnly(bits: 3..<4)
    var rxfrq: RXFRQ

    /// Mute mode request
    @WriteOnly(bits: 2..<3)
    var mmrq: MMRQ

    /// Send break request
    @WriteOnly(bits: 1..<2)
    var sbkrq: SBKRQ

    /// Auto baud rate request
    @WriteOnly(bits: 0..<1)
    var abrrq: ABRRQ
  }

  /// Interrupt & status register
  @Register(bitWidth: 32)
  struct ISR {
    /// REACK
    @ReadOnly(bits: 22..<23)
    var reack: REACK

    /// TEACK
    @ReadOnly(bits: 21..<22)
    var teack: TEACK

    /// WUF
    @ReadOnly(bits: 20..<21)
    var wuf: WUF

    /// RWU
    @ReadOnly(bits: 19..<20)
    var rwu: RWU

    /// SBKF
    @ReadOnly(bits: 18..<19)
    var sbkf: SBKF

    /// CMF
    @ReadOnly(bits: 17..<18)
    var cmf: CMF

    /// BUSY
    @ReadOnly(bits: 16..<17)
    var busy: BUSY

    /// ABRF
    @ReadOnly(bits: 15..<16)
    var abrf: ABRF

    /// ABRE
    @ReadOnly(bits: 14..<15)
    var abre: ABRE

    /// EOBF
    @ReadOnly(bits: 12..<13)
    var eobf: EOBF

    /// RTOF
    @ReadOnly(bits: 11..<12)
    var rtof: RTOF

    /// CTS
    @ReadOnly(bits: 10..<11)
    var cts: CTS

    /// CTSIF
    @ReadOnly(bits: 9..<10)
    var ctsif: CTSIF

    /// LBDF
    @ReadOnly(bits: 8..<9)
    var lbdf: LBDF

    /// TXE
    @ReadOnly(bits: 7..<8)
    var txe: TXE

    /// TC
    @ReadOnly(bits: 6..<7)
    var tc: TC

    /// RXNE
    @ReadOnly(bits: 5..<6)
    var rxne: RXNE

    /// IDLE
    @ReadOnly(bits: 4..<5)
    var idle: IDLE

    /// ORE
    @ReadOnly(bits: 3..<4)
    var ore: ORE

    /// NF
    @ReadOnly(bits: 2..<3)
    var nf: NF

    /// FE
    @ReadOnly(bits: 1..<2)
    var fe: FE

    /// PE
    @ReadOnly(bits: 0..<1)
    var pe: PE
  }

  /// Interrupt flag clear register
  @Register(bitWidth: 32)
  struct ICR {
    /// Wakeup from Stop mode clear flag
    @WriteOnly(bits: 20..<21)
    var wucf: WUCF

    /// Character match clear flag
    @WriteOnly(bits: 17..<18)
    var cmcf: CMCF

    /// End of block clear flag
    @WriteOnly(bits: 12..<13)
    var eobcf: EOBCF

    /// Receiver timeout clear flag
    @WriteOnly(bits: 11..<12)
    var rtocf: RTOCF

    /// CTS clear flag
    @WriteOnly(bits: 9..<10)
    var ctscf: CTSCF

    /// LIN break detection clear flag
    @WriteOnly(bits: 8..<9)
    var lbdcf: LBDCF

    /// Transmission complete clear flag
    @WriteOnly(bits: 6..<7)
    var tccf: TCCF

    /// Idle line detected clear flag
    @WriteOnly(bits: 4..<5)
    var idlecf: IDLECF

    /// Overrun error clear flag
    @WriteOnly(bits: 3..<4)
    var orecf: ORECF

    /// Noise detected clear flag
    @WriteOnly(bits: 2..<3)
    var ncf: NCF

    /// Framing error clear flag
    @WriteOnly(bits: 1..<2)
    var fecf: FECF

    /// Parity error clear flag
    @WriteOnly(bits: 0..<1)
    var pecf: PECF
  }

  /// Receive data register
  @Register(bitWidth: 32)
  struct RDR {
    /// Receive data value
    @ReadOnly(bits: 0..<9)
    var rdr_field: RDR_FIELD
  }

  /// Transmit data register
  @Register(bitWidth: 32)
  struct TDR {
    /// Transmit data value
    @ReadWrite(bits: 0..<9)
    var tdr_field: TDR_FIELD
  }
}

extension USART1.CR1 {
  struct M1Values: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Use M0 to set the data bits
    static let M0 = Self(rawValue: 0x0)

    /// 1 start bit, 7 data bits, n stop bits
    static let Bit7 = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct EOBIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Interrupt is inhibited
    static let Disabled = Self(rawValue: 0x0)

    /// A USART interrupt is generated when the EOBF flag is set in the ISR register
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct RTOIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Interrupt is inhibited
    static let Disabled = Self(rawValue: 0x0)

    /// An USART interrupt is generated when the RTOF bit is set in the ISR register
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct OVER8Values: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Oversampling by 16
    static let Oversampling16 = Self(rawValue: 0x0)

    /// Oversampling by 8
    static let Oversampling8 = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct CMIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Interrupt is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Interrupt is generated when the CMF bit is set in the ISR register
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct MMEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Receiver in active mode permanently
    static let Disabled = Self(rawValue: 0x0)

    /// Receiver can switch between mute mode and active mode
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct M0Values: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// 1 start bit, 8 data bits, n stop bits
    static let Bit8 = Self(rawValue: 0x0)

    /// 1 start bit, 9 data bits, n stop bits
    static let Bit9 = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct WAKEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Idle line
    static let Idle = Self(rawValue: 0x0)

    /// Address mask
    static let Address = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct PCEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Parity control disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Parity control enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct PSValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Even parity
    static let Even = Self(rawValue: 0x0)

    /// Odd parity
    static let Odd = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct PEIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Interrupt is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Interrupt is generated whenever PE=1 in the ISR register
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct TXEIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Interrupt is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Interrupt is generated whenever TXE=1 in the ISR register
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct TCIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Interrupt is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Interrupt is generated whenever TC=1 in the ISR register
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct RXNEIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Interrupt is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Interrupt is generated whenever ORE=1 or RXNE=1 in the ISR register
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct IDLEIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Interrupt is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Interrupt is generated whenever IDLE=1 in the ISR register
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct TEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Transmitter is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Transmitter is enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct REValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Receiver is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Receiver is enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct UESMValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// USART not able to wake up the MCU from Stop mode
    static let Disabled = Self(rawValue: 0x0)

    /// USART able to wake up the MCU from Stop mode
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  struct UEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// UART is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// UART is enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct RTOENValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Receiver timeout feature disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Receiver timeout feature enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct ABRENValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Auto baud rate detection is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Auto baud rate detection is enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct MSBFIRSTValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// data is transmitted/received with data bit 0 first, following the start bit
    static let LSB = Self(rawValue: 0x0)

    /// data is transmitted/received with MSB (bit 7/8/9) first, following the start bit
    static let MSB = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct DATAINVValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Logical data from the data register are send/received in positive/direct logic
    static let Positive = Self(rawValue: 0x0)

    /// Logical data from the data register are send/received in negative/inverse logic
    static let Negative = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct TXINVValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// TX pin signal works using the standard logic levels
    static let Standard = Self(rawValue: 0x0)

    /// TX pin signal values are inverted
    static let Inverted = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct RXINVValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// RX pin signal works using the standard logic levels
    static let Standard = Self(rawValue: 0x0)

    /// RX pin signal values are inverted
    static let Inverted = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct SWAPValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// TX/RX pins are used as defined in standard pinout
    static let Standard = Self(rawValue: 0x0)

    /// The TX and RX pins functions are swapped
    static let Swapped = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct LINENValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// LIN mode disabled
    static let Disabled = Self(rawValue: 0x0)

    /// LIN mode enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct STOPValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 2

    /// 1 stop bit
    static let Stop1 = Self(rawValue: 0x0)

    /// 0.5 stop bit
    static let Stop0p5 = Self(rawValue: 0x1)

    /// 2 stop bit
    static let Stop2 = Self(rawValue: 0x2)

    /// 1.5 stop bit
    static let Stop1p5 = Self(rawValue: 0x3)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct CLKENValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// CK pin disabled
    static let Disabled = Self(rawValue: 0x0)

    /// CK pin enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct CPOLValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Steady low value on CK pin outside transmission window
    static let Low = Self(rawValue: 0x0)

    /// Steady high value on CK pin outside transmission window
    static let High = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct CPHAValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// The first clock transition is the first data capture edge
    static let First = Self(rawValue: 0x0)

    /// The second clock transition is the first data capture edge
    static let Second = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct LBCLValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// The clock pulse of the last data bit is not output to the CK pin
    static let NotOutput = Self(rawValue: 0x0)

    /// The clock pulse of the last data bit is output to the CK pin
    static let Output = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct LBDIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Interrupt is inhibited
    static let Disabled = Self(rawValue: 0x0)

    /// An interrupt is generated whenever LBDF=1 in the ISR register
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct LBDLValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// 10-bit break detection
    static let Bit10 = Self(rawValue: 0x0)

    /// 11-bit break detection
    static let Bit11 = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct ADDM7Values: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// 4-bit address detection
    static let Bit4 = Self(rawValue: 0x0)

    /// 7-bit address detection
    static let Bit7 = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  struct ABRMODValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 2

    /// Measurement of the start bit is used to detect the baud rate
    static let Start = Self(rawValue: 0x0)

    /// Falling edge to falling edge measurement
    static let Edge = Self(rawValue: 0x1)

    /// 0x7F frame detection
    static let Frame7F = Self(rawValue: 0x2)

    /// 0x55 frame detection
    static let Frame55 = Self(rawValue: 0x3)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct WUFIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Interrupt is inhibited
    static let Disabled = Self(rawValue: 0x0)

    /// An USART interrupt is generated whenever WUF=1 in the ISR register
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct WUSValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 2

    /// WUF active on address match
    static let Address = Self(rawValue: 0x0)

    /// WuF active on Start bit detection
    static let Start = Self(rawValue: 0x2)

    /// WUF active on RXNE
    static let RXNE = Self(rawValue: 0x3)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct DEPValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// DE signal is active high
    static let High = Self(rawValue: 0x0)

    /// DE signal is active low
    static let Low = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct DEMValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// DE function is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// The DE signal is output on the RTS pin
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct DDREValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// DMA is not disabled in case of reception error
    static let NotDisabled = Self(rawValue: 0x0)

    /// DMA is disabled following a reception error
    static let Disabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct OVRDISValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Overrun Error Flag, ORE, is set when received data is not read before receiving new data
    static let Enabled = Self(rawValue: 0x0)

    /// Overrun functionality is disabled. If new data is received while the RXNE flag is still set the ORE flag is not set and the new received data overwrites the previous content of the RDR register
    static let Disabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct ONEBITValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Three sample bit method
    static let Sample3 = Self(rawValue: 0x0)

    /// One sample bit method
    static let Sample1 = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct CTSIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Interrupt is inhibited
    static let Disabled = Self(rawValue: 0x0)

    /// An interrupt is generated whenever CTSIF=1 in the ISR register
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct CTSEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// CTS hardware flow control disabled
    static let Disabled = Self(rawValue: 0x0)

    /// CTS mode enabled, data is only transmitted when the CTS input is asserted
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct RTSEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// RTS hardware flow control disabled
    static let Disabled = Self(rawValue: 0x0)

    /// RTS output enabled, data is only requested when there is space in the receive buffer
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct DMATValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// DMA mode is disabled for transmission
    static let Disabled = Self(rawValue: 0x0)

    /// DMA mode is enabled for transmission
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct DMARValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// DMA mode is disabled for reception
    static let Disabled = Self(rawValue: 0x0)

    /// DMA mode is enabled for reception
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct SCENValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Smartcard Mode disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Smartcard Mode enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct NACKValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// NACK transmission in case of parity error is disabled
    static let Disabled = Self(rawValue: 0x0)

    /// NACK transmission during parity error is enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct HDSELValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Half duplex mode is not selected
    static let NotSelected = Self(rawValue: 0x0)

    /// Half duplex mode is selected
    static let Selected = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct IRLPValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Normal mode
    static let Normal = Self(rawValue: 0x0)

    /// Low-power mode
    static let LowPower = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct IRENValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// IrDA disabled
    static let Disabled = Self(rawValue: 0x0)

    /// IrDA enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  struct EIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Interrupt is inhibited
    static let Disabled = Self(rawValue: 0x0)

    /// An interrupt is generated when FE=1 or ORE=1 or NF=1 in the ISR register
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}
