// Generated by svd2swift.

import MMIO

/// DMA controller
@RegisterBlock
struct DMA2 {
  /// low interrupt status register
  @RegisterBlock(offset: 0x0)
  var lisr: Register<LISR>

  /// high interrupt status register
  @RegisterBlock(offset: 0x4)
  var hisr: Register<HISR>

  /// low interrupt flag clear register
  @RegisterBlock(offset: 0x8)
  var lifcr: Register<LIFCR>

  /// high interrupt flag clear register
  @RegisterBlock(offset: 0xc)
  var hifcr: Register<HIFCR>

  /// Stream cluster: S?CR, S?NDTR, S?M0AR, S?M1AR and S?FCR registers
  @RegisterBlock(offset: 0x10, stride: 0x18, count: 8)
  var st: RegisterArray<ST>
}

extension DMA2 {
  /// low interrupt status register
  @Register(bitWidth: 32)
  struct LISR {
    /// Stream x transfer complete interrupt flag (x = 3..0)
    @ReadOnly(bits: 27..<28)
    var tcif3: TCIF3

    /// Stream x half transfer interrupt flag (x=3..0)
    @ReadOnly(bits: 26..<27)
    var htif3: HTIF3

    /// Stream x transfer error interrupt flag (x=3..0)
    @ReadOnly(bits: 25..<26)
    var teif3: TEIF3

    /// Stream x direct mode error interrupt flag (x=3..0)
    @ReadOnly(bits: 24..<25)
    var dmeif3: DMEIF3

    /// Stream x FIFO error interrupt flag (x=3..0)
    @ReadOnly(bits: 22..<23)
    var feif3: FEIF3

    /// Stream x transfer complete interrupt flag (x = 3..0)
    @ReadOnly(bits: 21..<22)
    var tcif2: TCIF2

    /// Stream x half transfer interrupt flag (x=3..0)
    @ReadOnly(bits: 20..<21)
    var htif2: HTIF2

    /// Stream x transfer error interrupt flag (x=3..0)
    @ReadOnly(bits: 19..<20)
    var teif2: TEIF2

    /// Stream x direct mode error interrupt flag (x=3..0)
    @ReadOnly(bits: 18..<19)
    var dmeif2: DMEIF2

    /// Stream x FIFO error interrupt flag (x=3..0)
    @ReadOnly(bits: 16..<17)
    var feif2: FEIF2

    /// Stream x transfer complete interrupt flag (x = 3..0)
    @ReadOnly(bits: 11..<12)
    var tcif1: TCIF1

    /// Stream x half transfer interrupt flag (x=3..0)
    @ReadOnly(bits: 10..<11)
    var htif1: HTIF1

    /// Stream x transfer error interrupt flag (x=3..0)
    @ReadOnly(bits: 9..<10)
    var teif1: TEIF1

    /// Stream x direct mode error interrupt flag (x=3..0)
    @ReadOnly(bits: 8..<9)
    var dmeif1: DMEIF1

    /// Stream x FIFO error interrupt flag (x=3..0)
    @ReadOnly(bits: 6..<7)
    var feif1: FEIF1

    /// Stream x transfer complete interrupt flag (x = 3..0)
    @ReadOnly(bits: 5..<6)
    var tcif0: TCIF0

    /// Stream x half transfer interrupt flag (x=3..0)
    @ReadOnly(bits: 4..<5)
    var htif0: HTIF0

    /// Stream x transfer error interrupt flag (x=3..0)
    @ReadOnly(bits: 3..<4)
    var teif0: TEIF0

    /// Stream x direct mode error interrupt flag (x=3..0)
    @ReadOnly(bits: 2..<3)
    var dmeif0: DMEIF0

    /// Stream x FIFO error interrupt flag (x=3..0)
    @ReadOnly(bits: 0..<1)
    var feif0: FEIF0
  }

  /// high interrupt status register
  @Register(bitWidth: 32)
  struct HISR {
    /// Stream x transfer complete interrupt flag (x=7..4)
    @ReadOnly(bits: 27..<28)
    var tcif7: TCIF7

    /// Stream x half transfer interrupt flag (x=7..4)
    @ReadOnly(bits: 26..<27)
    var htif7: HTIF7

    /// Stream x transfer error interrupt flag (x=7..4)
    @ReadOnly(bits: 25..<26)
    var teif7: TEIF7

    /// Stream x direct mode error interrupt flag (x=7..4)
    @ReadOnly(bits: 24..<25)
    var dmeif7: DMEIF7

    /// Stream x FIFO error interrupt flag (x=7..4)
    @ReadOnly(bits: 22..<23)
    var feif7: FEIF7

    /// Stream x transfer complete interrupt flag (x=7..4)
    @ReadOnly(bits: 21..<22)
    var tcif6: TCIF6

    /// Stream x half transfer interrupt flag (x=7..4)
    @ReadOnly(bits: 20..<21)
    var htif6: HTIF6

    /// Stream x transfer error interrupt flag (x=7..4)
    @ReadOnly(bits: 19..<20)
    var teif6: TEIF6

    /// Stream x direct mode error interrupt flag (x=7..4)
    @ReadOnly(bits: 18..<19)
    var dmeif6: DMEIF6

    /// Stream x FIFO error interrupt flag (x=7..4)
    @ReadOnly(bits: 16..<17)
    var feif6: FEIF6

    /// Stream x transfer complete interrupt flag (x=7..4)
    @ReadOnly(bits: 11..<12)
    var tcif5: TCIF5

    /// Stream x half transfer interrupt flag (x=7..4)
    @ReadOnly(bits: 10..<11)
    var htif5: HTIF5

    /// Stream x transfer error interrupt flag (x=7..4)
    @ReadOnly(bits: 9..<10)
    var teif5: TEIF5

    /// Stream x direct mode error interrupt flag (x=7..4)
    @ReadOnly(bits: 8..<9)
    var dmeif5: DMEIF5

    /// Stream x FIFO error interrupt flag (x=7..4)
    @ReadOnly(bits: 6..<7)
    var feif5: FEIF5

    /// Stream x transfer complete interrupt flag (x=7..4)
    @ReadOnly(bits: 5..<6)
    var tcif4: TCIF4

    /// Stream x half transfer interrupt flag (x=7..4)
    @ReadOnly(bits: 4..<5)
    var htif4: HTIF4

    /// Stream x transfer error interrupt flag (x=7..4)
    @ReadOnly(bits: 3..<4)
    var teif4: TEIF4

    /// Stream x direct mode error interrupt flag (x=7..4)
    @ReadOnly(bits: 2..<3)
    var dmeif4: DMEIF4

    /// Stream x FIFO error interrupt flag (x=7..4)
    @ReadOnly(bits: 0..<1)
    var feif4: FEIF4
  }

  /// low interrupt flag clear register
  @Register(bitWidth: 32)
  struct LIFCR {
    /// Stream x clear transfer complete interrupt flag (x = 3..0)
    @WriteOnly(bits: 27..<28)
    var ctcif3: CTCIF3

    /// Stream x clear half transfer interrupt flag (x = 3..0)
    @WriteOnly(bits: 26..<27)
    var chtif3: CHTIF3

    /// Stream x clear transfer error interrupt flag (x = 3..0)
    @WriteOnly(bits: 25..<26)
    var cteif3: CTEIF3

    /// Stream x clear direct mode error interrupt flag (x = 3..0)
    @WriteOnly(bits: 24..<25)
    var cdmeif3: CDMEIF3

    /// Stream x clear FIFO error interrupt flag (x = 3..0)
    @WriteOnly(bits: 22..<23)
    var cfeif3: CFEIF3

    /// Stream x clear transfer complete interrupt flag (x = 3..0)
    @WriteOnly(bits: 21..<22)
    var ctcif2: CTCIF2

    /// Stream x clear half transfer interrupt flag (x = 3..0)
    @WriteOnly(bits: 20..<21)
    var chtif2: CHTIF2

    /// Stream x clear transfer error interrupt flag (x = 3..0)
    @WriteOnly(bits: 19..<20)
    var cteif2: CTEIF2

    /// Stream x clear direct mode error interrupt flag (x = 3..0)
    @WriteOnly(bits: 18..<19)
    var cdmeif2: CDMEIF2

    /// Stream x clear FIFO error interrupt flag (x = 3..0)
    @WriteOnly(bits: 16..<17)
    var cfeif2: CFEIF2

    /// Stream x clear transfer complete interrupt flag (x = 3..0)
    @WriteOnly(bits: 11..<12)
    var ctcif1: CTCIF1

    /// Stream x clear half transfer interrupt flag (x = 3..0)
    @WriteOnly(bits: 10..<11)
    var chtif1: CHTIF1

    /// Stream x clear transfer error interrupt flag (x = 3..0)
    @WriteOnly(bits: 9..<10)
    var cteif1: CTEIF1

    /// Stream x clear direct mode error interrupt flag (x = 3..0)
    @WriteOnly(bits: 8..<9)
    var cdmeif1: CDMEIF1

    /// Stream x clear FIFO error interrupt flag (x = 3..0)
    @WriteOnly(bits: 6..<7)
    var cfeif1: CFEIF1

    /// Stream x clear transfer complete interrupt flag (x = 3..0)
    @WriteOnly(bits: 5..<6)
    var ctcif0: CTCIF0

    /// Stream x clear half transfer interrupt flag (x = 3..0)
    @WriteOnly(bits: 4..<5)
    var chtif0: CHTIF0

    /// Stream x clear transfer error interrupt flag (x = 3..0)
    @WriteOnly(bits: 3..<4)
    var cteif0: CTEIF0

    /// Stream x clear direct mode error interrupt flag (x = 3..0)
    @WriteOnly(bits: 2..<3)
    var cdmeif0: CDMEIF0

    /// Stream x clear FIFO error interrupt flag (x = 3..0)
    @WriteOnly(bits: 0..<1)
    var cfeif0: CFEIF0
  }

  /// high interrupt flag clear register
  @Register(bitWidth: 32)
  struct HIFCR {
    /// Stream x clear transfer complete interrupt flag (x = 7..4)
    @WriteOnly(bits: 27..<28)
    var ctcif7: CTCIF7

    /// Stream x clear half transfer interrupt flag (x = 7..4)
    @WriteOnly(bits: 26..<27)
    var chtif7: CHTIF7

    /// Stream x clear transfer error interrupt flag (x = 7..4)
    @WriteOnly(bits: 25..<26)
    var cteif7: CTEIF7

    /// Stream x clear direct mode error interrupt flag (x = 7..4)
    @WriteOnly(bits: 24..<25)
    var cdmeif7: CDMEIF7

    /// Stream x clear FIFO error interrupt flag (x = 7..4)
    @WriteOnly(bits: 22..<23)
    var cfeif7: CFEIF7

    /// Stream x clear transfer complete interrupt flag (x = 7..4)
    @WriteOnly(bits: 21..<22)
    var ctcif6: CTCIF6

    /// Stream x clear half transfer interrupt flag (x = 7..4)
    @WriteOnly(bits: 20..<21)
    var chtif6: CHTIF6

    /// Stream x clear transfer error interrupt flag (x = 7..4)
    @WriteOnly(bits: 19..<20)
    var cteif6: CTEIF6

    /// Stream x clear direct mode error interrupt flag (x = 7..4)
    @WriteOnly(bits: 18..<19)
    var cdmeif6: CDMEIF6

    /// Stream x clear FIFO error interrupt flag (x = 7..4)
    @WriteOnly(bits: 16..<17)
    var cfeif6: CFEIF6

    /// Stream x clear transfer complete interrupt flag (x = 7..4)
    @WriteOnly(bits: 11..<12)
    var ctcif5: CTCIF5

    /// Stream x clear half transfer interrupt flag (x = 7..4)
    @WriteOnly(bits: 10..<11)
    var chtif5: CHTIF5

    /// Stream x clear transfer error interrupt flag (x = 7..4)
    @WriteOnly(bits: 9..<10)
    var cteif5: CTEIF5

    /// Stream x clear direct mode error interrupt flag (x = 7..4)
    @WriteOnly(bits: 8..<9)
    var cdmeif5: CDMEIF5

    /// Stream x clear FIFO error interrupt flag (x = 7..4)
    @WriteOnly(bits: 6..<7)
    var cfeif5: CFEIF5

    /// Stream x clear transfer complete interrupt flag (x = 7..4)
    @WriteOnly(bits: 5..<6)
    var ctcif4: CTCIF4

    /// Stream x clear half transfer interrupt flag (x = 7..4)
    @WriteOnly(bits: 4..<5)
    var chtif4: CHTIF4

    /// Stream x clear transfer error interrupt flag (x = 7..4)
    @WriteOnly(bits: 3..<4)
    var cteif4: CTEIF4

    /// Stream x clear direct mode error interrupt flag (x = 7..4)
    @WriteOnly(bits: 2..<3)
    var cdmeif4: CDMEIF4

    /// Stream x clear FIFO error interrupt flag (x = 7..4)
    @WriteOnly(bits: 0..<1)
    var cfeif4: CFEIF4
  }

  /// Stream cluster: S?CR, S?NDTR, S?M0AR, S?M1AR and S?FCR registers
  @RegisterBlock
  struct ST {
    /// stream x configuration register
    @RegisterBlock(offset: 0x0)
    var cr: Register<CR>

    /// stream x number of data register
    @RegisterBlock(offset: 0x4)
    var ndtr: Register<NDTR>

    /// stream x peripheral address register
    @RegisterBlock(offset: 0x8)
    var par: Register<PAR>

    /// stream x memory 0 address register
    @RegisterBlock(offset: 0xc)
    var m0ar: Register<M0AR>

    /// stream x memory 1 address register
    @RegisterBlock(offset: 0x10)
    var m1ar: Register<M1AR>

    /// stream x FIFO control register
    @RegisterBlock(offset: 0x14)
    var fcr: Register<FCR>
  }
}

extension DMA2.ST {
  /// stream x configuration register
  @Register(bitWidth: 32)
  struct CR {
    /// Channel selection
    @ReadWrite(bits: 25..<28)
    var chsel: CHSEL

    /// Memory burst transfer configuration
    @ReadWrite(bits: 23..<25)
    var mburst: MBURST

    /// Peripheral burst transfer configuration
    @ReadWrite(bits: 21..<23, as: PBURSTValues.self)
    var pburst: PBURST

    /// Current target (only in double buffer mode)
    @ReadWrite(bits: 19..<20, as: CTValues.self)
    var ct: CT

    /// Double buffer mode
    @ReadWrite(bits: 18..<19, as: DBMValues.self)
    var dbm: DBM

    /// Priority level
    @ReadWrite(bits: 16..<18, as: PLValues.self)
    var pl: PL

    /// Peripheral increment offset size
    @ReadWrite(bits: 15..<16, as: PINCOSValues.self)
    var pincos: PINCOS

    /// Memory data size
    @ReadWrite(bits: 13..<15)
    var msize: MSIZE

    /// Peripheral data size
    @ReadWrite(bits: 11..<13, as: PSIZEValues.self)
    var psize: PSIZE

    /// Memory increment mode
    @ReadWrite(bits: 10..<11)
    var minc: MINC

    /// Peripheral increment mode
    @ReadWrite(bits: 9..<10, as: PINCValues.self)
    var pinc: PINC

    /// Circular mode
    @ReadWrite(bits: 8..<9, as: CIRCValues.self)
    var circ: CIRC

    /// Data transfer direction
    @ReadWrite(bits: 6..<8, as: DIRValues.self)
    var dir: DIR

    /// Peripheral flow controller
    @ReadWrite(bits: 5..<6, as: PFCTRLValues.self)
    var pfctrl: PFCTRL

    /// Transfer complete interrupt enable
    @ReadWrite(bits: 4..<5, as: TCIEValues.self)
    var tcie: TCIE

    /// Half transfer interrupt enable
    @ReadWrite(bits: 3..<4, as: HTIEValues.self)
    var htie: HTIE

    /// Transfer error interrupt enable
    @ReadWrite(bits: 2..<3, as: TEIEValues.self)
    var teie: TEIE

    /// Direct mode error interrupt enable
    @ReadWrite(bits: 1..<2, as: DMEIEValues.self)
    var dmeie: DMEIE

    /// Stream enable / flag stream ready when read low
    @ReadWrite(bits: 0..<1, as: ENValues.self)
    var en: EN
  }

  /// stream x number of data register
  @Register(bitWidth: 32)
  struct NDTR {
    /// Number of data items to transfer
    @ReadWrite(bits: 0..<16)
    var ndt: NDT
  }

  /// stream x peripheral address register
  @Register(bitWidth: 32)
  struct PAR {
    /// Peripheral address
    @ReadWrite(bits: 0..<32)
    var pa: PA
  }

  /// stream x memory 0 address register
  @Register(bitWidth: 32)
  struct M0AR {
    /// Memory 0 address
    @ReadWrite(bits: 0..<32)
    var m0a: M0A
  }

  /// stream x memory 1 address register
  @Register(bitWidth: 32)
  struct M1AR {
    /// Memory 1 address (used in case of Double buffer mode)
    @ReadWrite(bits: 0..<32)
    var m1a: M1A
  }

  /// stream x FIFO control register
  @Register(bitWidth: 32)
  struct FCR {
    /// FIFO error interrupt enable
    @ReadWrite(bits: 7..<8, as: FEIEValues.self)
    var feie: FEIE

    /// FIFO status
    @ReadOnly(bits: 3..<6)
    var fs: FS

    /// Direct mode disable
    @ReadWrite(bits: 2..<3, as: DMDISValues.self)
    var dmdis: DMDIS

    /// FIFO threshold selection
    @ReadWrite(bits: 0..<2, as: FTHValues.self)
    var fth: FTH
  }
}

extension DMA2.ST.CR {
  struct PBURSTValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 2

    /// Single transfer
    static let Single = Self(rawValue: 0x0)

    /// Incremental burst of 4 beats
    static let INCR4 = Self(rawValue: 0x1)

    /// Incremental burst of 8 beats
    static let INCR8 = Self(rawValue: 0x2)

    /// Incremental burst of 16 beats
    static let INCR16 = Self(rawValue: 0x3)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct CTValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// The current target memory is Memory 0
    static let Memory0 = Self(rawValue: 0x0)

    /// The current target memory is Memory 1
    static let Memory1 = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct DBMValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// No buffer switching at the end of transfer
    static let Disabled = Self(rawValue: 0x0)

    /// Memory target switched at the end of the DMA transfer
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct PLValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 2

    /// Low
    static let Low = Self(rawValue: 0x0)

    /// Medium
    static let Medium = Self(rawValue: 0x1)

    /// High
    static let High = Self(rawValue: 0x2)

    /// Very high
    static let VeryHigh = Self(rawValue: 0x3)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct PINCOSValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// The offset size for the peripheral address calculation is linked to the PSIZE
    static let PSIZE = Self(rawValue: 0x0)

    /// The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
    static let Fixed4 = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct PSIZEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 2

    /// Byte (8-bit)
    static let Bits8 = Self(rawValue: 0x0)

    /// Half-word (16-bit)
    static let Bits16 = Self(rawValue: 0x1)

    /// Word (32-bit)
    static let Bits32 = Self(rawValue: 0x2)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct PINCValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Address pointer is fixed
    static let Fixed = Self(rawValue: 0x0)

    /// Address pointer is incremented after each data transfer
    static let Incremented = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct CIRCValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Circular mode disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Circular mode enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct DIRValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 2

    /// Peripheral-to-memory
    static let PeripheralToMemory = Self(rawValue: 0x0)

    /// Memory-to-peripheral
    static let MemoryToPeripheral = Self(rawValue: 0x1)

    /// Memory-to-memory
    static let MemoryToMemory = Self(rawValue: 0x2)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct PFCTRLValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// The DMA is the flow controller
    static let DMA = Self(rawValue: 0x0)

    /// The peripheral is the flow controller
    static let Peripheral = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct TCIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// TC interrupt disabled
    static let Disabled = Self(rawValue: 0x0)

    /// TC interrupt enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct HTIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// HT interrupt disabled
    static let Disabled = Self(rawValue: 0x0)

    /// HT interrupt enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct TEIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// TE interrupt disabled
    static let Disabled = Self(rawValue: 0x0)

    /// TE interrupt enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct DMEIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// DME interrupt disabled
    static let Disabled = Self(rawValue: 0x0)

    /// DME interrupt enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.CR {
  struct ENValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Stream disabled
    static let Disabled = Self(rawValue: 0x0)

    /// Stream enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.FCR {
  struct FEIEValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// FE interrupt disabled
    static let Disabled = Self(rawValue: 0x0)

    /// FE interrupt enabled
    static let Enabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.FCR {
  struct DMDISValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 1

    /// Direct mode is enabled
    static let Enabled = Self(rawValue: 0x0)

    /// Direct mode is disabled
    static let Disabled = Self(rawValue: 0x1)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension DMA2.ST.FCR {
  struct FTHValues: BitFieldProjectable, RawRepresentable {
    static let bitWidth = 2

    /// 1/4 full FIFO
    static let Quarter = Self(rawValue: 0x0)

    /// 1/2 full FIFO
    static let Half = Self(rawValue: 0x1)

    /// 3/4 full FIFO
    static let ThreeQuarters = Self(rawValue: 0x2)

    /// Full FIFO
    static let Full = Self(rawValue: 0x3)

    var rawValue: UInt8

    @inlinable @inline(__always)
    init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}
