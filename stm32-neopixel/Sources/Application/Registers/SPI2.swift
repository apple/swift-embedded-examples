// Generated by svd2swift.

import MMIO

/// Serial peripheral interface
@RegisterBlock
struct SPI2 {
  /// control register 1
  @RegisterBlock(offset: 0x0)
  var cr1: Register<CR1>

  /// control register 2
  @RegisterBlock(offset: 0x4)
  var cr2: Register<CR2>

  /// status register
  @RegisterBlock(offset: 0x8)
  var sr: Register<SR>

  /// data register
  @RegisterBlock(offset: 0xc)
  var dr: Register<DR>

  /// CRC polynomial register
  @RegisterBlock(offset: 0x10)
  var crcpr: Register<CRCPR>

  /// RX CRC register
  @RegisterBlock(offset: 0x14)
  var rxcrcr: Register<RXCRCR>

  /// TX CRC register
  @RegisterBlock(offset: 0x18)
  var txcrcr: Register<TXCRCR>

  /// I2S configuration register
  @RegisterBlock(offset: 0x1c)
  var i2scfgr: Register<I2SCFGR>

  /// I2S prescaler register
  @RegisterBlock(offset: 0x20)
  var i2spr: Register<I2SPR>
}

extension SPI2 {
  /// control register 1
  @Register(bitWidth: 32)
  struct CR1 {
    /// Bidirectional data mode enable
    @ReadWrite(bits: 15..<16)
    var bidimode: BIDIMODE

    /// Output enable in bidirectional mode
    @ReadWrite(bits: 14..<15)
    var bidioe: BIDIOE

    /// Hardware CRC calculation enable
    @ReadWrite(bits: 13..<14)
    var crcen: CRCEN

    /// CRC transfer next
    @ReadWrite(bits: 12..<13)
    var crcnext: CRCNEXT

    /// CRC length
    @ReadWrite(bits: 11..<12)
    var crcl: CRCL

    /// Receive only
    @ReadWrite(bits: 10..<11)
    var rxonly: RXONLY

    /// Software slave management
    @ReadWrite(bits: 9..<10)
    var ssm: SSM

    /// Internal slave select
    @ReadWrite(bits: 8..<9)
    var ssi: SSI

    /// Frame format
    @ReadWrite(bits: 7..<8)
    var lsbfirst: LSBFIRST

    /// SPI enable
    @ReadWrite(bits: 6..<7)
    var spe: SPE

    /// Baud rate control
    @ReadWrite(bits: 3..<6)
    var br: BR

    /// Master selection
    @ReadWrite(bits: 2..<3)
    var mstr: MSTR

    /// Clock polarity
    @ReadWrite(bits: 1..<2)
    var cpol: CPOL

    /// Clock phase
    @ReadWrite(bits: 0..<1)
    var cpha: CPHA
  }

  /// control register 2
  @Register(bitWidth: 32)
  struct CR2 {
    /// Rx buffer DMA enable
    @ReadWrite(bits: 0..<1)
    var rxdmaen: RXDMAEN

    /// Tx buffer DMA enable
    @ReadWrite(bits: 1..<2)
    var txdmaen: TXDMAEN

    /// SS output enable
    @ReadWrite(bits: 2..<3)
    var ssoe: SSOE

    /// NSS pulse management
    @ReadWrite(bits: 3..<4)
    var nssp: NSSP

    /// Frame format
    @ReadWrite(bits: 4..<5)
    var frf: FRF

    /// Error interrupt enable
    @ReadWrite(bits: 5..<6)
    var errie: ERRIE

    /// RX buffer not empty interrupt enable
    @ReadWrite(bits: 6..<7)
    var rxneie: RXNEIE

    /// Tx buffer empty interrupt enable
    @ReadWrite(bits: 7..<8)
    var txeie: TXEIE

    /// Data size
    @ReadWrite(bits: 8..<12)
    var ds: DS

    /// FIFO reception threshold
    @ReadWrite(bits: 12..<13)
    var frxth: FRXTH

    /// Last DMA transfer for reception
    @ReadWrite(bits: 13..<14)
    var ldma_rx: LDMA_RX

    /// Last DMA transfer for transmission
    @ReadWrite(bits: 14..<15)
    var ldma_tx: LDMA_TX
  }

  /// status register
  @Register(bitWidth: 32)
  struct SR {
    /// Busy flag
    @ReadOnly(bits: 7..<8)
    var bsy: BSY

    /// Overrun flag
    @ReadOnly(bits: 6..<7)
    var ovr: OVR

    /// Mode fault
    @ReadOnly(bits: 5..<6)
    var modf: MODF

    /// CRC error flag
    @ReadWrite(bits: 4..<5)
    var crcerr: CRCERR

    /// Underrun flag
    @ReadOnly(bits: 3..<4)
    var udr: UDR

    /// Channel side
    @ReadOnly(bits: 2..<3)
    var chside: CHSIDE

    /// Transmit buffer empty
    @ReadOnly(bits: 1..<2)
    var txe: TXE

    /// Receive buffer not empty
    @ReadOnly(bits: 0..<1)
    var rxne: RXNE

    /// Frame format error
    @ReadOnly(bits: 8..<9)
    var fre: FRE

    /// FIFO reception level
    @ReadOnly(bits: 9..<11)
    var frlvl: FRLVL

    /// FIFO Transmission Level
    @ReadOnly(bits: 11..<13)
    var ftlvl: FTLVL
  }

  /// data register
  @Register(bitWidth: 32)
  struct DR {
    /// Data register
    @ReadWrite(bits: 0..<16)
    var dr_field: DR_FIELD
  }

  /// CRC polynomial register
  @Register(bitWidth: 32)
  struct CRCPR {
    /// CRC polynomial register
    @ReadWrite(bits: 0..<16)
    var crcpoly: CRCPOLY
  }

  /// RX CRC register
  @Register(bitWidth: 32)
  struct RXCRCR {
    /// Rx CRC register
    @ReadOnly(bits: 0..<16)
    var rxcrc: RxCRC
  }

  /// TX CRC register
  @Register(bitWidth: 32)
  struct TXCRCR {
    /// Tx CRC register
    @ReadOnly(bits: 0..<16)
    var txcrc: TxCRC
  }

  /// I2S configuration register
  @Register(bitWidth: 32)
  struct I2SCFGR {
    /// I2S mode selection
    @ReadWrite(bits: 11..<12)
    var i2smod: I2SMOD

    /// I2S Enable
    @ReadWrite(bits: 10..<11)
    var i2se: I2SE

    /// I2S configuration mode
    @ReadWrite(bits: 8..<10)
    var i2scfg: I2SCFG

    /// PCM frame synchronization
    @ReadWrite(bits: 7..<8)
    var pcmsync: PCMSYNC

    /// I2S standard selection
    @ReadWrite(bits: 4..<6)
    var i2sstd: I2SSTD

    /// Steady state clock polarity
    @ReadWrite(bits: 3..<4)
    var ckpol: CKPOL

    /// Data length to be transferred
    @ReadWrite(bits: 1..<3)
    var datlen: DATLEN

    /// Channel length (number of bits per audio channel)
    @ReadWrite(bits: 0..<1)
    var chlen: CHLEN

    /// Asynchronous start enable
    @ReadWrite(bits: 12..<13)
    var astrten: ASTRTEN
  }

  /// I2S prescaler register
  @Register(bitWidth: 32)
  struct I2SPR {
    /// Master clock output enable
    @ReadWrite(bits: 9..<10)
    var mckoe: MCKOE

    /// Odd factor for the prescaler
    @ReadWrite(bits: 8..<9)
    var odd: ODD

    /// I2S Linear prescaler
    @ReadWrite(bits: 0..<8)
    var i2sdiv: I2SDIV
  }
}
