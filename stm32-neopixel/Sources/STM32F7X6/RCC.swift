// Generated by svd2swift.

import MMIO

/// Reset and clock control
@RegisterBlock
public struct RCC {
  /// clock control register
  @RegisterBlock(offset: 0x0)
  public var cr: Register<CR>

  /// PLL configuration register
  @RegisterBlock(offset: 0x4)
  public var pllcfgr: Register<PLLCFGR>

  /// clock configuration register
  @RegisterBlock(offset: 0x8)
  public var cfgr: Register<CFGR>

  /// clock interrupt register
  @RegisterBlock(offset: 0xc)
  public var cir: Register<CIR>

  /// AHB1 peripheral reset register
  @RegisterBlock(offset: 0x10)
  public var ahb1rstr: Register<AHB1RSTR>

  /// AHB2 peripheral reset register
  @RegisterBlock(offset: 0x14)
  public var ahb2rstr: Register<AHB2RSTR>

  /// AHB3 peripheral reset register
  @RegisterBlock(offset: 0x18)
  public var ahb3rstr: Register<AHB3RSTR>

  /// APB1 peripheral reset register
  @RegisterBlock(offset: 0x20)
  public var apb1rstr: Register<APB1RSTR>

  /// APB2 peripheral reset register
  @RegisterBlock(offset: 0x24)
  public var apb2rstr: Register<APB2RSTR>

  /// AHB1 peripheral clock register
  @RegisterBlock(offset: 0x30)
  public var ahb1enr: Register<AHB1ENR>

  /// AHB2 peripheral clock enable register
  @RegisterBlock(offset: 0x34)
  public var ahb2enr: Register<AHB2ENR>

  /// AHB3 peripheral clock enable register
  @RegisterBlock(offset: 0x38)
  public var ahb3enr: Register<AHB3ENR>

  /// APB1 peripheral clock enable register
  @RegisterBlock(offset: 0x40)
  public var apb1enr: Register<APB1ENR>

  /// APB2 peripheral clock enable register
  @RegisterBlock(offset: 0x44)
  public var apb2enr: Register<APB2ENR>

  /// AHB1 peripheral clock enable in low power mode register
  @RegisterBlock(offset: 0x50)
  public var ahb1lpenr: Register<AHB1LPENR>

  /// AHB2 peripheral clock enable in low power mode register
  @RegisterBlock(offset: 0x54)
  public var ahb2lpenr: Register<AHB2LPENR>

  /// AHB3 peripheral clock enable in low power mode register
  @RegisterBlock(offset: 0x58)
  public var ahb3lpenr: Register<AHB3LPENR>

  /// APB1 peripheral clock enable in low power mode register
  @RegisterBlock(offset: 0x60)
  public var apb1lpenr: Register<APB1LPENR>

  /// APB2 peripheral clock enabled in low power mode register
  @RegisterBlock(offset: 0x64)
  public var apb2lpenr: Register<APB2LPENR>

  /// Backup domain control register
  @RegisterBlock(offset: 0x70)
  public var bdcr: Register<BDCR>

  /// clock control & status register
  @RegisterBlock(offset: 0x74)
  public var csr: Register<CSR>

  /// spread spectrum clock generation register
  @RegisterBlock(offset: 0x80)
  public var sscgr: Register<SSCGR>

  /// PLLI2S configuration register
  @RegisterBlock(offset: 0x84)
  public var plli2scfgr: Register<PLLI2SCFGR>

  /// PLL configuration register
  @RegisterBlock(offset: 0x88)
  public var pllsaicfgr: Register<PLLSAICFGR>

  /// dedicated clocks configuration register
  @RegisterBlock(offset: 0x8c)
  public var dckcfgr1: Register<DCKCFGR1>

  /// dedicated clocks configuration register
  @RegisterBlock(offset: 0x90)
  public var dckcfgr2: Register<DCKCFGR2>
}

extension RCC {
  /// clock control register
  @Register(bitWidth: 32)
  public struct CR {
    /// PLLI2S clock ready flag
    @ReadOnly(bits: 27..<28)
    public var plli2srdy: PLLI2SRDY

    /// PLLI2S enable
    @ReadWrite(bits: 26..<27)
    public var plli2son: PLLI2SON

    /// Main PLL (PLL) clock ready flag
    @ReadOnly(bits: 25..<26)
    public var pllrdy: PLLRDY

    /// Main PLL (PLL) enable
    @ReadWrite(bits: 24..<25)
    public var pllon: PLLON

    /// Clock security system enable
    @ReadWrite(bits: 19..<20, as: CSSONValues.self)
    public var csson: CSSON

    /// HSE clock bypass
    @ReadWrite(bits: 18..<19, as: HSEBYPValues.self)
    public var hsebyp: HSEBYP

    /// HSE clock ready flag
    @ReadOnly(bits: 17..<18)
    public var hserdy: HSERDY

    /// HSE clock enable
    @ReadWrite(bits: 16..<17)
    public var hseon: HSEON

    /// Internal high-speed clock calibration
    @ReadOnly(bits: 8..<16)
    public var hsical: HSICAL

    /// Internal high-speed clock trimming
    @ReadWrite(bits: 3..<8)
    public var hsitrim: HSITRIM

    /// Internal high-speed clock ready flag
    @ReadOnly(bits: 1..<2)
    public var hsirdy: HSIRDY

    /// Internal high-speed clock enable
    @ReadWrite(bits: 0..<1, as: HSIONValues.self)
    public var hsion: HSION

    /// PLLSAI clock ready flag
    @ReadOnly(bits: 29..<30)
    public var pllsairdy: PLLSAIRDY

    /// PLLSAI enable
    @ReadWrite(bits: 28..<29)
    public var pllsaion: PLLSAION
  }

  /// PLL configuration register
  @Register(bitWidth: 32)
  public struct PLLCFGR {
    /// Main PLL(PLL) and audio PLL (PLLI2S) entry clock source
    @ReadWrite(bits: 22..<23, as: PLLSRCValues.self)
    public var pllsrc: PLLSRC

    /// Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
    @ReadWrite(bits: 0..<6)
    public var pllm: PLLM

    /// Main PLL (PLL) multiplication factor for VCO
    @ReadWrite(bits: 6..<15)
    public var plln: PLLN

    /// Main PLL (PLL) division factor for main system clock
    @ReadWrite(bits: 16..<18, as: PLLPValues.self)
    public var pllp: PLLP

    /// Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
    @ReadWrite(bits: 24..<28)
    public var pllq: PLLQ
  }

  /// clock configuration register
  @Register(bitWidth: 32)
  public struct CFGR {
    /// Microcontroller clock output 2
    @ReadWrite(bits: 30..<32, as: MCO2Values.self)
    public var mco2: MCO2

    /// MCO2 prescaler
    @ReadWrite(bits: 27..<30)
    public var mco2pre: MCO2PRE

    /// MCO1 prescaler
    @ReadWrite(bits: 24..<27, as: MCO1PREValues.self)
    public var mco1pre: MCO1PRE

    /// I2S clock selection
    @ReadWrite(bits: 23..<24, as: I2SSRCValues.self)
    public var i2ssrc: I2SSRC

    /// Microcontroller clock output 1
    @ReadWrite(bits: 21..<23, as: MCO1Values.self)
    public var mco1: MCO1

    /// HSE division factor for RTC clock
    @ReadWrite(bits: 16..<21)
    public var rtcpre: RTCPRE

    /// APB high-speed prescaler (APB2)
    @ReadWrite(bits: 13..<16)
    public var ppre2: PPRE2

    /// APB Low speed prescaler (APB1)
    @ReadWrite(bits: 10..<13, as: PPRE1Values.self)
    public var ppre1: PPRE1

    /// AHB prescaler
    @ReadWrite(bits: 4..<8, as: HPREValues.self)
    public var hpre: HPRE

    /// System clock switch
    @Reserved(bits: 0..<2, as: SWValues.self)
    public var sw: SW

    /// System clock switch status
    @Reserved(bits: 2..<4)
    public var sws: SWS
  }

  /// clock interrupt register
  @Register(bitWidth: 32)
  public struct CIR {
    /// Clock security system interrupt clear
    @WriteOnly(bits: 23..<24)
    public var cssc: CSSC

    /// PLLSAI Ready Interrupt Clear
    @WriteOnly(bits: 22..<23)
    public var pllsairdyc: PLLSAIRDYC

    /// PLLI2S ready interrupt clear
    @WriteOnly(bits: 21..<22)
    public var plli2srdyc: PLLI2SRDYC

    /// Main PLL(PLL) ready interrupt clear
    @WriteOnly(bits: 20..<21)
    public var pllrdyc: PLLRDYC

    /// HSE ready interrupt clear
    @WriteOnly(bits: 19..<20)
    public var hserdyc: HSERDYC

    /// HSI ready interrupt clear
    @WriteOnly(bits: 18..<19)
    public var hsirdyc: HSIRDYC

    /// LSE ready interrupt clear
    @WriteOnly(bits: 17..<18)
    public var lserdyc: LSERDYC

    /// LSI ready interrupt clear
    @WriteOnly(bits: 16..<17)
    public var lsirdyc: LSIRDYC

    /// PLLSAI Ready Interrupt Enable
    @ReadWrite(bits: 14..<15)
    public var pllsairdyie: PLLSAIRDYIE

    /// PLLI2S ready interrupt enable
    @ReadWrite(bits: 13..<14)
    public var plli2srdyie: PLLI2SRDYIE

    /// Main PLL (PLL) ready interrupt enable
    @ReadWrite(bits: 12..<13)
    public var pllrdyie: PLLRDYIE

    /// HSE ready interrupt enable
    @ReadWrite(bits: 11..<12)
    public var hserdyie: HSERDYIE

    /// HSI ready interrupt enable
    @ReadWrite(bits: 10..<11)
    public var hsirdyie: HSIRDYIE

    /// LSE ready interrupt enable
    @ReadWrite(bits: 9..<10)
    public var lserdyie: LSERDYIE

    /// LSI ready interrupt enable
    @ReadWrite(bits: 8..<9, as: LSIRDYIEValues.self)
    public var lsirdyie: LSIRDYIE

    /// Clock security system interrupt flag
    @ReadOnly(bits: 7..<8)
    public var cssf: CSSF

    /// PLLSAI ready interrupt flag
    @ReadOnly(bits: 6..<7)
    public var pllsairdyf: PLLSAIRDYF

    /// PLLI2S ready interrupt flag
    @ReadOnly(bits: 5..<6)
    public var plli2srdyf: PLLI2SRDYF

    /// Main PLL (PLL) ready interrupt flag
    @ReadOnly(bits: 4..<5)
    public var pllrdyf: PLLRDYF

    /// HSE ready interrupt flag
    @ReadOnly(bits: 3..<4)
    public var hserdyf: HSERDYF

    /// HSI ready interrupt flag
    @ReadOnly(bits: 2..<3)
    public var hsirdyf: HSIRDYF

    /// LSE ready interrupt flag
    @ReadOnly(bits: 1..<2)
    public var lserdyf: LSERDYF

    /// LSI ready interrupt flag
    @ReadOnly(bits: 0..<1)
    public var lsirdyf: LSIRDYF
  }

  /// AHB1 peripheral reset register
  @Register(bitWidth: 32)
  public struct AHB1RSTR {
    /// USB OTG HS module reset
    @ReadWrite(bits: 29..<30)
    public var otghsrst: OTGHSRST

    /// Ethernet MAC reset
    @ReadWrite(bits: 25..<26)
    public var ethmacrst: ETHMACRST

    /// DMA2D reset
    @ReadWrite(bits: 23..<24)
    public var dma2drst: DMA2DRST

    /// DMA2 reset
    @ReadWrite(bits: 22..<23)
    public var dma2rst: DMA2RST

    /// DMA2 reset
    @ReadWrite(bits: 21..<22)
    public var dma1rst: DMA1RST

    /// CRC reset
    @ReadWrite(bits: 12..<13)
    public var crcrst: CRCRST

    /// IO port K reset
    @ReadWrite(bits: 10..<11)
    public var gpiokrst: GPIOKRST

    /// IO port J reset
    @ReadWrite(bits: 9..<10)
    public var gpiojrst: GPIOJRST

    /// IO port I reset
    @ReadWrite(bits: 8..<9)
    public var gpioirst: GPIOIRST

    /// IO port H reset
    @ReadWrite(bits: 7..<8)
    public var gpiohrst: GPIOHRST

    /// IO port G reset
    @ReadWrite(bits: 6..<7)
    public var gpiogrst: GPIOGRST

    /// IO port F reset
    @ReadWrite(bits: 5..<6)
    public var gpiofrst: GPIOFRST

    /// IO port E reset
    @ReadWrite(bits: 4..<5)
    public var gpioerst: GPIOERST

    /// IO port D reset
    @ReadWrite(bits: 3..<4)
    public var gpiodrst: GPIODRST

    /// IO port C reset
    @ReadWrite(bits: 2..<3)
    public var gpiocrst: GPIOCRST

    /// IO port B reset
    @ReadWrite(bits: 1..<2)
    public var gpiobrst: GPIOBRST

    /// IO port A reset
    @ReadWrite(bits: 0..<1, as: GPIOARSTValues.self)
    public var gpioarst: GPIOARST
  }

  /// AHB2 peripheral reset register
  @Register(bitWidth: 32)
  public struct AHB2RSTR {
    /// USB OTG FS module reset
    @ReadWrite(bits: 7..<8)
    public var otgfsrst: OTGFSRST

    /// Random number generator module reset
    @ReadWrite(bits: 6..<7)
    public var rngrst: RNGRST

    /// Hash module reset
    @ReadWrite(bits: 5..<6)
    public var hsahrst: HSAHRST

    /// Cryptographic module reset
    @ReadWrite(bits: 4..<5)
    public var cryprst: CRYPRST

    /// Camera interface reset
    @ReadWrite(bits: 0..<1, as: DCMIRSTValues.self)
    public var dcmirst: DCMIRST
  }

  /// AHB3 peripheral reset register
  @Register(bitWidth: 32)
  public struct AHB3RSTR {
    /// Flexible memory controller module reset
    @ReadWrite(bits: 0..<1, as: FMCRSTValues.self)
    public var fmcrst: FMCRST

    /// Quad SPI memory controller reset
    @ReadWrite(bits: 1..<2)
    public var qspirst: QSPIRST
  }

  /// APB1 peripheral reset register
  @Register(bitWidth: 32)
  public struct APB1RSTR {
    /// TIM2 reset
    @ReadWrite(bits: 0..<1, as: TIM2RSTValues.self)
    public var tim2rst: TIM2RST

    /// TIM3 reset
    @ReadWrite(bits: 1..<2)
    public var tim3rst: TIM3RST

    /// TIM4 reset
    @ReadWrite(bits: 2..<3)
    public var tim4rst: TIM4RST

    /// TIM5 reset
    @ReadWrite(bits: 3..<4)
    public var tim5rst: TIM5RST

    /// TIM6 reset
    @ReadWrite(bits: 4..<5)
    public var tim6rst: TIM6RST

    /// TIM7 reset
    @ReadWrite(bits: 5..<6)
    public var tim7rst: TIM7RST

    /// TIM12 reset
    @ReadWrite(bits: 6..<7)
    public var tim12rst: TIM12RST

    /// TIM13 reset
    @ReadWrite(bits: 7..<8)
    public var tim13rst: TIM13RST

    /// TIM14 reset
    @ReadWrite(bits: 8..<9)
    public var tim14rst: TIM14RST

    /// Window watchdog reset
    @ReadWrite(bits: 11..<12)
    public var wwdgrst: WWDGRST

    /// SPI 2 reset
    @ReadWrite(bits: 14..<15)
    public var spi2rst: SPI2RST

    /// SPI 3 reset
    @ReadWrite(bits: 15..<16)
    public var spi3rst: SPI3RST

    /// USART 2 reset
    @ReadWrite(bits: 17..<18)
    public var usart2rst: USART2RST

    /// USART 3 reset
    @ReadWrite(bits: 18..<19)
    public var usart3rst: USART3RST

    /// USART 4 reset
    @ReadWrite(bits: 19..<20)
    public var uart4rst: UART4RST

    /// USART 5 reset
    @ReadWrite(bits: 20..<21)
    public var uart5rst: UART5RST

    /// I2C 1 reset
    @ReadWrite(bits: 21..<22)
    public var i2c1rst: I2C1RST

    /// I2C 2 reset
    @ReadWrite(bits: 22..<23)
    public var i2c2rst: I2C2RST

    /// I2C3 reset
    @ReadWrite(bits: 23..<24)
    public var i2c3rst: I2C3RST

    /// CAN1 reset
    @ReadWrite(bits: 25..<26)
    public var can1rst: CAN1RST

    /// CAN2 reset
    @ReadWrite(bits: 26..<27)
    public var can2rst: CAN2RST

    /// Power interface reset
    @ReadWrite(bits: 28..<29)
    public var pwrrst: PWRRST

    /// DAC reset
    @ReadWrite(bits: 29..<30)
    public var dacrst: DACRST

    /// UART7 reset
    @ReadWrite(bits: 30..<31)
    public var uart7rst: UART7RST

    /// UART8 reset
    @ReadWrite(bits: 31..<32)
    public var uart8rst: UART8RST

    /// SPDIF-RX reset
    @ReadWrite(bits: 16..<17)
    public var spdifrxrst: SPDIFRXRST

    /// HDMI-CEC reset
    @ReadWrite(bits: 27..<28)
    public var cecrst: CECRST

    /// Low power timer 1 reset
    @ReadWrite(bits: 9..<10)
    public var lptim1rst: LPTIM1RST

    /// I2C 4 reset
    @ReadWrite(bits: 24..<25)
    public var i2c4rst: I2C4RST
  }

  /// APB2 peripheral reset register
  @Register(bitWidth: 32)
  public struct APB2RSTR {
    /// TIM1 reset
    @ReadWrite(bits: 0..<1, as: TIM1RSTValues.self)
    public var tim1rst: TIM1RST

    /// TIM8 reset
    @ReadWrite(bits: 1..<2)
    public var tim8rst: TIM8RST

    /// USART1 reset
    @ReadWrite(bits: 4..<5)
    public var usart1rst: USART1RST

    /// USART6 reset
    @ReadWrite(bits: 5..<6)
    public var usart6rst: USART6RST

    /// ADC interface reset (common to all ADCs)
    @ReadWrite(bits: 8..<9)
    public var adcrst: ADCRST

    /// SPI 1 reset
    @ReadWrite(bits: 12..<13)
    public var spi1rst: SPI1RST

    /// SPI4 reset
    @ReadWrite(bits: 13..<14)
    public var spi4rst: SPI4RST

    /// System configuration controller reset
    @ReadWrite(bits: 14..<15)
    public var syscfgrst: SYSCFGRST

    /// TIM9 reset
    @ReadWrite(bits: 16..<17)
    public var tim9rst: TIM9RST

    /// TIM10 reset
    @ReadWrite(bits: 17..<18)
    public var tim10rst: TIM10RST

    /// TIM11 reset
    @ReadWrite(bits: 18..<19)
    public var tim11rst: TIM11RST

    /// SPI5 reset
    @ReadWrite(bits: 20..<21)
    public var spi5rst: SPI5RST

    /// SPI6 reset
    @ReadWrite(bits: 21..<22)
    public var spi6rst: SPI6RST

    /// SAI1 reset
    @ReadWrite(bits: 22..<23)
    public var sai1rst: SAI1RST

    /// LTDC reset
    @ReadWrite(bits: 26..<27)
    public var ltdcrst: LTDCRST

    /// SAI2 reset
    @ReadWrite(bits: 23..<24)
    public var sai2rst: SAI2RST

    /// SDMMC1 reset
    @ReadWrite(bits: 11..<12)
    public var sdmmc1rst: SDMMC1RST
  }

  /// AHB1 peripheral clock register
  @Register(bitWidth: 32)
  public struct AHB1ENR {
    /// USB OTG HSULPI clock enable
    @ReadWrite(bits: 30..<31)
    public var otghsulpien: OTGHSULPIEN

    /// USB OTG HS clock enable
    @ReadWrite(bits: 29..<30)
    public var otghsen: OTGHSEN

    /// Ethernet PTP clock enable
    @ReadWrite(bits: 28..<29)
    public var ethmacptpen: ETHMACPTPEN

    /// Ethernet Reception clock enable
    @ReadWrite(bits: 27..<28)
    public var ethmacrxen: ETHMACRXEN

    /// Ethernet Transmission clock enable
    @ReadWrite(bits: 26..<27)
    public var ethmactxen: ETHMACTXEN

    /// Ethernet MAC clock enable
    @ReadWrite(bits: 25..<26)
    public var ethmacen: ETHMACEN

    /// DMA2D clock enable
    @ReadWrite(bits: 23..<24)
    public var dma2den: DMA2DEN

    /// DMA2 clock enable
    @ReadWrite(bits: 22..<23)
    public var dma2en: DMA2EN

    /// DMA1 clock enable
    @ReadWrite(bits: 21..<22)
    public var dma1en: DMA1EN

    /// CCM data RAM clock enable
    @ReadWrite(bits: 20..<21)
    public var dtcmramen: DTCMRAMEN

    /// Backup SRAM interface clock enable
    @ReadWrite(bits: 18..<19)
    public var bkpsramen: BKPSRAMEN

    /// CRC clock enable
    @ReadWrite(bits: 12..<13)
    public var crcen: CRCEN

    /// IO port K clock enable
    @ReadWrite(bits: 10..<11)
    public var gpioken: GPIOKEN

    /// IO port J clock enable
    @ReadWrite(bits: 9..<10)
    public var gpiojen: GPIOJEN

    /// IO port I clock enable
    @ReadWrite(bits: 8..<9)
    public var gpioien: GPIOIEN

    /// IO port H clock enable
    @ReadWrite(bits: 7..<8)
    public var gpiohen: GPIOHEN

    /// IO port G clock enable
    @ReadWrite(bits: 6..<7)
    public var gpiogen: GPIOGEN

    /// IO port F clock enable
    @ReadWrite(bits: 5..<6)
    public var gpiofen: GPIOFEN

    /// IO port E clock enable
    @ReadWrite(bits: 4..<5)
    public var gpioeen: GPIOEEN

    /// IO port D clock enable
    @ReadWrite(bits: 3..<4)
    public var gpioden: GPIODEN

    /// IO port C clock enable
    @ReadWrite(bits: 2..<3)
    public var gpiocen: GPIOCEN

    /// IO port B clock enable
    @ReadWrite(bits: 1..<2)
    public var gpioben: GPIOBEN

    /// IO port A clock enable
    @ReadWrite(bits: 0..<1, as: GPIOAENValues.self)
    public var gpioaen: GPIOAEN
  }

  /// AHB2 peripheral clock enable register
  @Register(bitWidth: 32)
  public struct AHB2ENR {
    /// USB OTG FS clock enable
    @ReadWrite(bits: 7..<8)
    public var otgfsen: OTGFSEN

    /// Random number generator clock enable
    @ReadWrite(bits: 6..<7)
    public var rngen: RNGEN

    /// Hash modules clock enable
    @ReadWrite(bits: 5..<6)
    public var hashen: HASHEN

    /// Cryptographic modules clock enable
    @ReadWrite(bits: 4..<5)
    public var crypen: CRYPEN

    /// Camera interface enable
    @ReadWrite(bits: 0..<1, as: DCMIENValues.self)
    public var dcmien: DCMIEN
  }

  /// AHB3 peripheral clock enable register
  @Register(bitWidth: 32)
  public struct AHB3ENR {
    /// Flexible memory controller module clock enable
    @ReadWrite(bits: 0..<1, as: FMCENValues.self)
    public var fmcen: FMCEN

    /// Quad SPI memory controller clock enable
    @ReadWrite(bits: 1..<2)
    public var qspien: QSPIEN
  }

  /// APB1 peripheral clock enable register
  @Register(bitWidth: 32)
  public struct APB1ENR {
    /// TIM2 clock enable
    @ReadWrite(bits: 0..<1, as: TIM2ENValues.self)
    public var tim2en: TIM2EN

    /// TIM3 clock enable
    @ReadWrite(bits: 1..<2)
    public var tim3en: TIM3EN

    /// TIM4 clock enable
    @ReadWrite(bits: 2..<3)
    public var tim4en: TIM4EN

    /// TIM5 clock enable
    @ReadWrite(bits: 3..<4)
    public var tim5en: TIM5EN

    /// TIM6 clock enable
    @ReadWrite(bits: 4..<5)
    public var tim6en: TIM6EN

    /// TIM7 clock enable
    @ReadWrite(bits: 5..<6)
    public var tim7en: TIM7EN

    /// TIM12 clock enable
    @ReadWrite(bits: 6..<7)
    public var tim12en: TIM12EN

    /// TIM13 clock enable
    @ReadWrite(bits: 7..<8)
    public var tim13en: TIM13EN

    /// TIM14 clock enable
    @ReadWrite(bits: 8..<9)
    public var tim14en: TIM14EN

    /// Window watchdog clock enable
    @ReadWrite(bits: 11..<12)
    public var wwdgen: WWDGEN

    /// SPI2 clock enable
    @ReadWrite(bits: 14..<15)
    public var spi2en: SPI2EN

    /// SPI3 clock enable
    @ReadWrite(bits: 15..<16)
    public var spi3en: SPI3EN

    /// USART 2 clock enable
    @ReadWrite(bits: 17..<18)
    public var usart2en: USART2EN

    /// USART3 clock enable
    @ReadWrite(bits: 18..<19)
    public var usart3en: USART3EN

    /// UART4 clock enable
    @ReadWrite(bits: 19..<20)
    public var uart4en: UART4EN

    /// UART5 clock enable
    @ReadWrite(bits: 20..<21)
    public var uart5en: UART5EN

    /// I2C1 clock enable
    @ReadWrite(bits: 21..<22)
    public var i2c1en: I2C1EN

    /// I2C2 clock enable
    @ReadWrite(bits: 22..<23)
    public var i2c2en: I2C2EN

    /// I2C3 clock enable
    @ReadWrite(bits: 23..<24)
    public var i2c3en: I2C3EN

    /// CAN 1 clock enable
    @ReadWrite(bits: 25..<26)
    public var can1en: CAN1EN

    /// CAN 2 clock enable
    @ReadWrite(bits: 26..<27)
    public var can2en: CAN2EN

    /// Power interface clock enable
    @ReadWrite(bits: 28..<29)
    public var pwren: PWREN

    /// DAC interface clock enable
    @ReadWrite(bits: 29..<30)
    public var dacen: DACEN

    /// UART7 clock enable
    @ReadWrite(bits: 30..<31)
    public var uart7en: UART7EN

    /// UART8 clock enable
    @ReadWrite(bits: 31..<32)
    public var uart8en: UART8EN

    /// SPDIF-RX clock enable
    @ReadWrite(bits: 16..<17)
    public var spdifrxen: SPDIFRXEN

    /// HDMI-CEN clock enable
    @ReadWrite(bits: 27..<28)
    public var cecen: CECEN

    /// Low power timer 1 clock enable
    @ReadWrite(bits: 9..<10)
    public var lptim1en: LPTIM1EN

    /// I2C4 clock enable
    @ReadWrite(bits: 24..<25)
    public var i2c4en: I2C4EN
  }

  /// APB2 peripheral clock enable register
  @Register(bitWidth: 32)
  public struct APB2ENR {
    /// TIM1 clock enable
    @ReadWrite(bits: 0..<1, as: TIM1ENValues.self)
    public var tim1en: TIM1EN

    /// TIM8 clock enable
    @ReadWrite(bits: 1..<2)
    public var tim8en: TIM8EN

    /// USART1 clock enable
    @ReadWrite(bits: 4..<5)
    public var usart1en: USART1EN

    /// USART6 clock enable
    @ReadWrite(bits: 5..<6)
    public var usart6en: USART6EN

    /// ADC1 clock enable
    @ReadWrite(bits: 8..<9)
    public var adc1en: ADC1EN

    /// ADC2 clock enable
    @ReadWrite(bits: 9..<10)
    public var adc2en: ADC2EN

    /// ADC3 clock enable
    @ReadWrite(bits: 10..<11)
    public var adc3en: ADC3EN

    /// SPI1 clock enable
    @ReadWrite(bits: 12..<13)
    public var spi1en: SPI1EN

    /// SPI4 clock enable
    @ReadWrite(bits: 13..<14)
    public var spi4en: SPI4EN

    /// System configuration controller clock enable
    @ReadWrite(bits: 14..<15)
    public var syscfgen: SYSCFGEN

    /// TIM9 clock enable
    @ReadWrite(bits: 16..<17)
    public var tim9en: TIM9EN

    /// TIM10 clock enable
    @ReadWrite(bits: 17..<18)
    public var tim10en: TIM10EN

    /// TIM11 clock enable
    @ReadWrite(bits: 18..<19)
    public var tim11en: TIM11EN

    /// SPI5 clock enable
    @ReadWrite(bits: 20..<21)
    public var spi5en: SPI5EN

    /// SPI6 clock enable
    @ReadWrite(bits: 21..<22)
    public var spi6en: SPI6EN

    /// SAI1 clock enable
    @ReadWrite(bits: 22..<23)
    public var sai1en: SAI1EN

    /// LTDC clock enable
    @ReadWrite(bits: 26..<27)
    public var ltdcen: LTDCEN

    /// SAI2 clock enable
    @ReadWrite(bits: 23..<24)
    public var sai2en: SAI2EN

    /// SDMMC1 clock enable
    @ReadWrite(bits: 11..<12)
    public var sdmmc1en: SDMMC1EN
  }

  /// AHB1 peripheral clock enable in low power mode register
  @Register(bitWidth: 32)
  public struct AHB1LPENR {
    /// IO port A clock enable during sleep mode
    @ReadWrite(bits: 0..<1, as: GPIOALPENValues.self)
    public var gpioalpen: GPIOALPEN

    /// IO port B clock enable during Sleep mode
    @ReadWrite(bits: 1..<2)
    public var gpioblpen: GPIOBLPEN

    /// IO port C clock enable during Sleep mode
    @ReadWrite(bits: 2..<3)
    public var gpioclpen: GPIOCLPEN

    /// IO port D clock enable during Sleep mode
    @ReadWrite(bits: 3..<4)
    public var gpiodlpen: GPIODLPEN

    /// IO port E clock enable during Sleep mode
    @ReadWrite(bits: 4..<5)
    public var gpioelpen: GPIOELPEN

    /// IO port F clock enable during Sleep mode
    @ReadWrite(bits: 5..<6)
    public var gpioflpen: GPIOFLPEN

    /// IO port G clock enable during Sleep mode
    @ReadWrite(bits: 6..<7)
    public var gpioglpen: GPIOGLPEN

    /// IO port H clock enable during Sleep mode
    @ReadWrite(bits: 7..<8)
    public var gpiohlpen: GPIOHLPEN

    /// IO port I clock enable during Sleep mode
    @ReadWrite(bits: 8..<9)
    public var gpioilpen: GPIOILPEN

    /// IO port J clock enable during Sleep mode
    @ReadWrite(bits: 9..<10)
    public var gpiojlpen: GPIOJLPEN

    /// IO port K clock enable during Sleep mode
    @ReadWrite(bits: 10..<11)
    public var gpioklpen: GPIOKLPEN

    /// CRC clock enable during Sleep mode
    @ReadWrite(bits: 12..<13)
    public var crclpen: CRCLPEN

    /// Flash interface clock enable during Sleep mode
    @ReadWrite(bits: 15..<16)
    public var flitflpen: FLITFLPEN

    /// SRAM 1interface clock enable during Sleep mode
    @ReadWrite(bits: 16..<17)
    public var sram1lpen: SRAM1LPEN

    /// SRAM 2 interface clock enable during Sleep mode
    @ReadWrite(bits: 17..<18)
    public var sram2lpen: SRAM2LPEN

    /// Backup SRAM interface clock enable during Sleep mode
    @ReadWrite(bits: 18..<19)
    public var bkpsramlpen: BKPSRAMLPEN

    /// SRAM 3 interface clock enable during Sleep mode
    @ReadWrite(bits: 19..<20)
    public var sram3lpen: SRAM3LPEN

    /// DMA1 clock enable during Sleep mode
    @ReadWrite(bits: 21..<22)
    public var dma1lpen: DMA1LPEN

    /// DMA2 clock enable during Sleep mode
    @ReadWrite(bits: 22..<23)
    public var dma2lpen: DMA2LPEN

    /// DMA2D clock enable during Sleep mode
    @ReadWrite(bits: 23..<24)
    public var dma2dlpen: DMA2DLPEN

    /// Ethernet MAC clock enable during Sleep mode
    @ReadWrite(bits: 25..<26)
    public var ethmaclpen: ETHMACLPEN

    /// Ethernet transmission clock enable during Sleep mode
    @ReadWrite(bits: 26..<27)
    public var ethmactxlpen: ETHMACTXLPEN

    /// Ethernet reception clock enable during Sleep mode
    @ReadWrite(bits: 27..<28)
    public var ethmacrxlpen: ETHMACRXLPEN

    /// Ethernet PTP clock enable during Sleep mode
    @ReadWrite(bits: 28..<29)
    public var ethmacptplpen: ETHMACPTPLPEN

    /// USB OTG HS clock enable during Sleep mode
    @ReadWrite(bits: 29..<30)
    public var otghslpen: OTGHSLPEN

    /// USB OTG HS ULPI clock enable during Sleep mode
    @ReadWrite(bits: 30..<31)
    public var otghsulpilpen: OTGHSULPILPEN

    /// AXI to AHB bridge clock enable during Sleep mode
    @ReadWrite(bits: 13..<14)
    public var axilpen: AXILPEN

    /// DTCM RAM interface clock enable during Sleep mode
    @ReadWrite(bits: 20..<21)
    public var dtcmlpen: DTCMLPEN
  }

  /// AHB2 peripheral clock enable in low power mode register
  @Register(bitWidth: 32)
  public struct AHB2LPENR {
    /// USB OTG FS clock enable during Sleep mode
    @ReadWrite(bits: 7..<8)
    public var otgfslpen: OTGFSLPEN

    /// Random number generator clock enable during Sleep mode
    @ReadWrite(bits: 6..<7)
    public var rnglpen: RNGLPEN

    /// Hash modules clock enable during Sleep mode
    @ReadWrite(bits: 5..<6)
    public var hashlpen: HASHLPEN

    /// Cryptography modules clock enable during Sleep mode
    @ReadWrite(bits: 4..<5)
    public var cryplpen: CRYPLPEN

    /// Camera interface enable during Sleep mode
    @ReadWrite(bits: 0..<1, as: DCMILPENValues.self)
    public var dcmilpen: DCMILPEN
  }

  /// AHB3 peripheral clock enable in low power mode register
  @Register(bitWidth: 32)
  public struct AHB3LPENR {
    /// Flexible memory controller module clock enable during Sleep mode
    @ReadWrite(bits: 0..<1, as: FMCLPENValues.self)
    public var fmclpen: FMCLPEN

    /// Quand SPI memory controller clock enable during Sleep mode
    @ReadWrite(bits: 1..<2)
    public var qspilpen: QSPILPEN
  }

  /// APB1 peripheral clock enable in low power mode register
  @Register(bitWidth: 32)
  public struct APB1LPENR {
    /// TIM2 clock enable during Sleep mode
    @ReadWrite(bits: 0..<1, as: TIM2LPENValues.self)
    public var tim2lpen: TIM2LPEN

    /// TIM3 clock enable during Sleep mode
    @ReadWrite(bits: 1..<2)
    public var tim3lpen: TIM3LPEN

    /// TIM4 clock enable during Sleep mode
    @ReadWrite(bits: 2..<3)
    public var tim4lpen: TIM4LPEN

    /// TIM5 clock enable during Sleep mode
    @ReadWrite(bits: 3..<4)
    public var tim5lpen: TIM5LPEN

    /// TIM6 clock enable during Sleep mode
    @ReadWrite(bits: 4..<5)
    public var tim6lpen: TIM6LPEN

    /// TIM7 clock enable during Sleep mode
    @ReadWrite(bits: 5..<6)
    public var tim7lpen: TIM7LPEN

    /// TIM12 clock enable during Sleep mode
    @ReadWrite(bits: 6..<7)
    public var tim12lpen: TIM12LPEN

    /// TIM13 clock enable during Sleep mode
    @ReadWrite(bits: 7..<8)
    public var tim13lpen: TIM13LPEN

    /// TIM14 clock enable during Sleep mode
    @ReadWrite(bits: 8..<9)
    public var tim14lpen: TIM14LPEN

    /// Window watchdog clock enable during Sleep mode
    @ReadWrite(bits: 11..<12)
    public var wwdglpen: WWDGLPEN

    /// SPI2 clock enable during Sleep mode
    @ReadWrite(bits: 14..<15)
    public var spi2lpen: SPI2LPEN

    /// SPI3 clock enable during Sleep mode
    @ReadWrite(bits: 15..<16)
    public var spi3lpen: SPI3LPEN

    /// USART2 clock enable during Sleep mode
    @ReadWrite(bits: 17..<18)
    public var usart2lpen: USART2LPEN

    /// USART3 clock enable during Sleep mode
    @ReadWrite(bits: 18..<19)
    public var usart3lpen: USART3LPEN

    /// UART4 clock enable during Sleep mode
    @ReadWrite(bits: 19..<20)
    public var uart4lpen: UART4LPEN

    /// UART5 clock enable during Sleep mode
    @ReadWrite(bits: 20..<21)
    public var uart5lpen: UART5LPEN

    /// I2C1 clock enable during Sleep mode
    @ReadWrite(bits: 21..<22)
    public var i2c1lpen: I2C1LPEN

    /// I2C2 clock enable during Sleep mode
    @ReadWrite(bits: 22..<23)
    public var i2c2lpen: I2C2LPEN

    /// I2C3 clock enable during Sleep mode
    @ReadWrite(bits: 23..<24)
    public var i2c3lpen: I2C3LPEN

    /// CAN 1 clock enable during Sleep mode
    @ReadWrite(bits: 25..<26)
    public var can1lpen: CAN1LPEN

    /// CAN 2 clock enable during Sleep mode
    @ReadWrite(bits: 26..<27)
    public var can2lpen: CAN2LPEN

    /// Power interface clock enable during Sleep mode
    @ReadWrite(bits: 28..<29)
    public var pwrlpen: PWRLPEN

    /// DAC interface clock enable during Sleep mode
    @ReadWrite(bits: 29..<30)
    public var daclpen: DACLPEN

    /// UART7 clock enable during Sleep mode
    @ReadWrite(bits: 30..<31)
    public var uart7lpen: UART7LPEN

    /// UART8 clock enable during Sleep mode
    @ReadWrite(bits: 31..<32)
    public var uart8lpen: UART8LPEN

    /// SPDIF-RX clock enable during sleep mode
    @ReadWrite(bits: 16..<17)
    public var spdifrxlpen: SPDIFRXLPEN

    /// HDMI-CEN clock enable during Sleep mode
    @ReadWrite(bits: 27..<28)
    public var ceclpen: CECLPEN

    /// low power timer 1 clock enable during Sleep mode
    @ReadWrite(bits: 9..<10)
    public var lptim1lpen: LPTIM1LPEN

    /// I2C4 clock enable during Sleep mode
    @ReadWrite(bits: 24..<25)
    public var i2c4lpen: I2C4LPEN
  }

  /// APB2 peripheral clock enabled in low power mode register
  @Register(bitWidth: 32)
  public struct APB2LPENR {
    /// TIM1 clock enable during Sleep mode
    @ReadWrite(bits: 0..<1, as: TIM1LPENValues.self)
    public var tim1lpen: TIM1LPEN

    /// TIM8 clock enable during Sleep mode
    @ReadWrite(bits: 1..<2)
    public var tim8lpen: TIM8LPEN

    /// USART1 clock enable during Sleep mode
    @ReadWrite(bits: 4..<5)
    public var usart1lpen: USART1LPEN

    /// USART6 clock enable during Sleep mode
    @ReadWrite(bits: 5..<6)
    public var usart6lpen: USART6LPEN

    /// ADC1 clock enable during Sleep mode
    @ReadWrite(bits: 8..<9)
    public var adc1lpen: ADC1LPEN

    /// ADC2 clock enable during Sleep mode
    @ReadWrite(bits: 9..<10)
    public var adc2lpen: ADC2LPEN

    /// ADC 3 clock enable during Sleep mode
    @ReadWrite(bits: 10..<11)
    public var adc3lpen: ADC3LPEN

    /// SPI 1 clock enable during Sleep mode
    @ReadWrite(bits: 12..<13)
    public var spi1lpen: SPI1LPEN

    /// SPI 4 clock enable during Sleep mode
    @ReadWrite(bits: 13..<14)
    public var spi4lpen: SPI4LPEN

    /// System configuration controller clock enable during Sleep mode
    @ReadWrite(bits: 14..<15)
    public var syscfglpen: SYSCFGLPEN

    /// TIM9 clock enable during sleep mode
    @ReadWrite(bits: 16..<17)
    public var tim9lpen: TIM9LPEN

    /// TIM10 clock enable during Sleep mode
    @ReadWrite(bits: 17..<18)
    public var tim10lpen: TIM10LPEN

    /// TIM11 clock enable during Sleep mode
    @ReadWrite(bits: 18..<19)
    public var tim11lpen: TIM11LPEN

    /// SPI 5 clock enable during Sleep mode
    @ReadWrite(bits: 20..<21)
    public var spi5lpen: SPI5LPEN

    /// SPI 6 clock enable during Sleep mode
    @ReadWrite(bits: 21..<22)
    public var spi6lpen: SPI6LPEN

    /// SAI1 clock enable during sleep mode
    @ReadWrite(bits: 22..<23)
    public var sai1lpen: SAI1LPEN

    /// LTDC clock enable during sleep mode
    @ReadWrite(bits: 26..<27)
    public var ltdclpen: LTDCLPEN

    /// SAI2 clock enable during sleep mode
    @ReadWrite(bits: 23..<24)
    public var sai2lpen: SAI2LPEN

    /// SDMMC1 clock enable during Sleep mode
    @ReadWrite(bits: 11..<12)
    public var sdmmc1lpen: SDMMC1LPEN
  }

  /// Backup domain control register
  @Register(bitWidth: 32)
  public struct BDCR {
    /// Backup domain software reset
    @ReadWrite(bits: 16..<17, as: BDRSTValues.self)
    public var bdrst: BDRST

    /// RTC clock enable
    @ReadWrite(bits: 15..<16, as: RTCENValues.self)
    public var rtcen: RTCEN

    /// External low-speed oscillator bypass
    @ReadWrite(bits: 2..<3, as: LSEBYPValues.self)
    public var lsebyp: LSEBYP

    /// External low-speed oscillator ready
    @ReadOnly(bits: 1..<2)
    public var lserdy: LSERDY

    /// External low-speed oscillator enable
    @ReadWrite(bits: 0..<1, as: LSEONValues.self)
    public var lseon: LSEON

    /// LSE oscillator drive capability
    @ReadWrite(bits: 3..<5, as: LSEDRVValues.self)
    public var lsedrv: LSEDRV

    /// RTC clock source selection
    @Reserved(bits: 8..<10, as: RTCSELValues.self)
    public var rtcsel: RTCSEL
  }

  /// clock control & status register
  @Register(bitWidth: 32)
  public struct CSR {
    /// Low-power reset flag
    @ReadWrite(bits: 31..<32)
    public var lpwrrstf: LPWRRSTF

    /// Window watchdog reset flag
    @ReadWrite(bits: 30..<31)
    public var wwdgrstf: WWDGRSTF

    /// Independent watchdog reset flag
    @ReadWrite(bits: 29..<30)
    public var wdgrstf: WDGRSTF

    /// Software reset flag
    @ReadWrite(bits: 28..<29)
    public var sftrstf: SFTRSTF

    /// POR/PDR reset flag
    @ReadWrite(bits: 27..<28)
    public var porrstf: PORRSTF

    /// PIN reset flag
    @ReadWrite(bits: 26..<27)
    public var padrstf: PADRSTF

    /// BOR reset flag
    @ReadWrite(bits: 25..<26)
    public var borrstf: BORRSTF

    /// Remove reset flag
    @ReadWrite(bits: 24..<25)
    public var rmvf: RMVF

    /// Internal low-speed oscillator ready
    @ReadOnly(bits: 1..<2)
    public var lsirdy: LSIRDY

    /// Internal low-speed oscillator enable
    @ReadWrite(bits: 0..<1, as: LSIONValues.self)
    public var lsion: LSION
  }

  /// spread spectrum clock generation register
  @Register(bitWidth: 32)
  public struct SSCGR {
    /// Spread spectrum modulation enable
    @ReadWrite(bits: 31..<32, as: SSCGENValues.self)
    public var sscgen: SSCGEN

    /// Spread Select
    @ReadWrite(bits: 30..<31, as: SPREADSELValues.self)
    public var spreadsel: SPREADSEL

    /// Incrementation step
    @ReadWrite(bits: 13..<28)
    public var incstep: INCSTEP

    /// Modulation period
    @ReadWrite(bits: 0..<13)
    public var modper: MODPER
  }

  /// PLLI2S configuration register
  @Register(bitWidth: 32)
  public struct PLLI2SCFGR {
    /// PLLI2S division factor for I2S clocks
    @ReadWrite(bits: 28..<31)
    public var plli2sr: PLLI2SR

    /// PLLI2S division factor for SAI1 clock
    @ReadWrite(bits: 24..<28)
    public var plli2sq: PLLI2SQ

    /// PLLI2S multiplication factor for VCO
    @ReadWrite(bits: 6..<15)
    public var plli2sn: PLLI2SN

    /// PLLI2S division factor for SPDIFRX clock
    @ReadWrite(bits: 16..<18, as: PLLI2SPValues.self)
    public var plli2sp: PLLI2SP
  }

  /// PLL configuration register
  @Register(bitWidth: 32)
  public struct PLLSAICFGR {
    /// PLLSAI division factor for VCO
    @ReadWrite(bits: 6..<15)
    public var pllsain: PLLSAIN

    /// PLLSAI division factor for 48MHz clock
    @ReadWrite(bits: 16..<18, as: PLLSAIPValues.self)
    public var pllsaip: PLLSAIP

    /// PLLSAI division factor for SAI clock
    @ReadWrite(bits: 24..<28)
    public var pllsaiq: PLLSAIQ

    /// PLLSAI division factor for LCD clock
    @ReadWrite(bits: 28..<31)
    public var pllsair: PLLSAIR
  }

  /// dedicated clocks configuration register
  @Register(bitWidth: 32)
  public struct DCKCFGR1 {
    /// PLLI2S division factor for SAI1 clock
    @ReadWrite(bits: 0..<5, as: PLLI2SDIVQValues.self)
    public var plli2sdivq: PLLI2SDIVQ

    /// PLLSAI division factor for SAI1 clock
    @ReadWrite(bits: 8..<13, as: PLLSAIDIVQValues.self)
    public var pllsaidivq: PLLSAIDIVQ

    /// division factor for LCD_CLK
    @ReadWrite(bits: 16..<18, as: PLLSAIDIVRValues.self)
    public var pllsaidivr: PLLSAIDIVR

    /// SAI1 clock source selection
    @ReadWrite(bits: 20..<22, as: SAI1SELValues.self)
    public var sai1sel: SAI1SEL

    /// SAI2 clock source selection
    @ReadWrite(bits: 22..<24, as: SAI2SELValues.self)
    public var sai2sel: SAI2SEL

    /// Timers clocks prescalers selection
    @ReadWrite(bits: 24..<25, as: TIMPREValues.self)
    public var timpre: TIMPRE
  }

  /// dedicated clocks configuration register
  @Register(bitWidth: 32)
  public struct DCKCFGR2 {
    /// USART 1 clock source selection
    @ReadWrite(bits: 0..<2, as: USART1SELValues.self)
    public var usart1sel: USART1SEL

    /// USART 2 clock source selection
    @ReadWrite(bits: 2..<4, as: USART2SELValues.self)
    public var usart2sel: USART2SEL

    /// USART 3 clock source selection
    @ReadWrite(bits: 4..<6)
    public var usart3sel: USART3SEL

    /// UART 4 clock source selection
    @ReadWrite(bits: 6..<8)
    public var uart4sel: UART4SEL

    /// UART 5 clock source selection
    @ReadWrite(bits: 8..<10)
    public var uart5sel: UART5SEL

    /// USART 6 clock source selection
    @ReadWrite(bits: 10..<12)
    public var usart6sel: USART6SEL

    /// UART 7 clock source selection
    @ReadWrite(bits: 12..<14)
    public var uart7sel: UART7SEL

    /// UART 8 clock source selection
    @ReadWrite(bits: 14..<16)
    public var uart8sel: UART8SEL

    /// I2C1 clock source selection
    @ReadWrite(bits: 16..<18, as: I2C1SELValues.self)
    public var i2c1sel: I2C1SEL

    /// I2C2 clock source selection
    @ReadWrite(bits: 18..<20)
    public var i2c2sel: I2C2SEL

    /// I2C3 clock source selection
    @ReadWrite(bits: 20..<22)
    public var i2c3sel: I2C3SEL

    /// I2C4 clock source selection
    @ReadWrite(bits: 22..<24)
    public var i2c4sel: I2C4SEL

    /// Low power timer 1 clock source selection
    @ReadWrite(bits: 24..<26, as: LPTIM1SELValues.self)
    public var lptim1sel: LPTIM1SEL

    /// HDMI-CEC clock source selection
    @ReadWrite(bits: 26..<27, as: CECSELValues.self)
    public var cecsel: CECSEL

    /// 48MHz clock source selection
    @ReadWrite(bits: 27..<28, as: CK48MSELValues.self)
    public var ck48msel: CK48MSEL

    /// SDMMC clock source selection
    @ReadWrite(bits: 28..<29, as: SDMMC1SELValues.self)
    public var sdmmc1sel: SDMMC1SEL
  }
}

extension RCC.CR {
  public struct CSSONValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Clock security system disabled (clock detector OFF)
    public static let Off = Self(rawValue: 0x0)

    /// Clock security system enable (clock detector ON if the HSE is ready, OFF if not)
    public static let On = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.CR {
  public struct HSEBYPValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// HSE crystal oscillator not bypassed
    public static let NotBypassed = Self(rawValue: 0x0)

    /// HSE crystal oscillator bypassed with external clock
    public static let Bypassed = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.CR {
  public struct HSIONValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Clock Off
    public static let Off = Self(rawValue: 0x0)

    /// Clock On
    public static let On = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.PLLCFGR {
  public struct PLLSRCValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// HSI clock selected as PLL and PLLI2S clock entry
    public static let HSI = Self(rawValue: 0x0)

    /// HSE oscillator clock selected as PLL and PLLI2S clock entry
    public static let HSE = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.PLLCFGR {
  public struct PLLPValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// PLLP=2
    public static let Div2 = Self(rawValue: 0x0)

    /// PLLP=4
    public static let Div4 = Self(rawValue: 0x1)

    /// PLLP=6
    public static let Div6 = Self(rawValue: 0x2)

    /// PLLP=8
    public static let Div8 = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.CFGR {
  public struct MCO2Values: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// System clock (SYSCLK) selected
    public static let SYSCLK = Self(rawValue: 0x0)

    /// PLLI2S clock selected
    public static let PLLI2S = Self(rawValue: 0x1)

    /// HSE oscillator clock selected
    public static let HSE = Self(rawValue: 0x2)

    /// PLL clock selected
    public static let PLL = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.CFGR {
  public struct MCO1PREValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 3

    /// No division
    public static let Div1 = Self(rawValue: 0x0)

    /// Division by 2
    public static let Div2 = Self(rawValue: 0x4)

    /// Division by 3
    public static let Div3 = Self(rawValue: 0x5)

    /// Division by 4
    public static let Div4 = Self(rawValue: 0x6)

    /// Division by 5
    public static let Div5 = Self(rawValue: 0x7)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.CFGR {
  public struct I2SSRCValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// PLLI2S clock used as I2S clock source
    public static let PLLI2S = Self(rawValue: 0x0)

    /// External clock mapped on the I2S_CKIN pin used as I2S clock source
    public static let CKIN = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.CFGR {
  public struct MCO1Values: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// HSI clock selected
    public static let HSI = Self(rawValue: 0x0)

    /// LSE oscillator selected
    public static let LSE = Self(rawValue: 0x1)

    /// HSE oscillator clock selected
    public static let HSE = Self(rawValue: 0x2)

    /// PLL clock selected
    public static let PLL = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.CFGR {
  public struct PPRE1Values: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 3

    /// HCLK not divided
    public static let Div1 = Self(rawValue: 0x0)

    /// HCLK divided by 2
    public static let Div2 = Self(rawValue: 0x4)

    /// HCLK divided by 4
    public static let Div4 = Self(rawValue: 0x5)

    /// HCLK divided by 8
    public static let Div8 = Self(rawValue: 0x6)

    /// HCLK divided by 16
    public static let Div16 = Self(rawValue: 0x7)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.CFGR {
  public struct HPREValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 4

    /// SYSCLK not divided
    public static let Div1 = Self(rawValue: 0x0)

    /// SYSCLK divided by 2
    public static let Div2 = Self(rawValue: 0x8)

    /// SYSCLK divided by 4
    public static let Div4 = Self(rawValue: 0x9)

    /// SYSCLK divided by 8
    public static let Div8 = Self(rawValue: 0xa)

    /// SYSCLK divided by 16
    public static let Div16 = Self(rawValue: 0xb)

    /// SYSCLK divided by 64
    public static let Div64 = Self(rawValue: 0xc)

    /// SYSCLK divided by 128
    public static let Div128 = Self(rawValue: 0xd)

    /// SYSCLK divided by 256
    public static let Div256 = Self(rawValue: 0xe)

    /// SYSCLK divided by 512
    public static let Div512 = Self(rawValue: 0xf)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.CFGR {
  public struct SWValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// HSI selected as system clock
    public static let HSI = Self(rawValue: 0x0)

    /// HSE selected as system clock
    public static let HSE = Self(rawValue: 0x1)

    /// PLL selected as system clock
    public static let PLL = Self(rawValue: 0x2)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.CIR {
  public struct LSIRDYIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Interrupt enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.AHB1RSTR {
  public struct GPIOARSTValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Reset the selected module
    public static let Reset = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.AHB2RSTR {
  public struct DCMIRSTValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Reset the selected module
    public static let Reset = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.AHB3RSTR {
  public struct FMCRSTValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Reset the selected module
    public static let Reset = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.APB1RSTR {
  public struct TIM2RSTValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Reset the selected module
    public static let Reset = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.APB2RSTR {
  public struct TIM1RSTValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Reset the selected module
    public static let Reset = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.AHB1ENR {
  public struct GPIOAENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// The selected clock is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// The selected clock is enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.AHB2ENR {
  public struct DCMIENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// The selected clock is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// The selected clock is enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.AHB3ENR {
  public struct FMCENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// The selected clock is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// The selected clock is enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.APB1ENR {
  public struct TIM2ENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// The selected clock is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// The selected clock is enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.APB2ENR {
  public struct TIM1ENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// The selected clock is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// The selected clock is enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.AHB1LPENR {
  public struct GPIOALPENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Selected module is disabled during Sleep mode
    public static let DisabledInSleep = Self(rawValue: 0x0)

    /// Selected module is enabled during Sleep mode
    public static let EnabledInSleep = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.AHB2LPENR {
  public struct DCMILPENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Selected module is disabled during Sleep mode
    public static let DisabledInSleep = Self(rawValue: 0x0)

    /// Selected module is enabled during Sleep mode
    public static let EnabledInSleep = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.AHB3LPENR {
  public struct FMCLPENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Selected module is disabled during Sleep mode
    public static let DisabledInSleep = Self(rawValue: 0x0)

    /// Selected module is enabled during Sleep mode
    public static let EnabledInSleep = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.APB1LPENR {
  public struct TIM2LPENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Selected module is disabled during Sleep mode
    public static let DisabledInSleep = Self(rawValue: 0x0)

    /// Selected module is enabled during Sleep mode
    public static let EnabledInSleep = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.APB2LPENR {
  public struct TIM1LPENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Selected module is disabled during Sleep mode
    public static let DisabledInSleep = Self(rawValue: 0x0)

    /// Selected module is enabled during Sleep mode
    public static let EnabledInSleep = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.BDCR {
  public struct BDRSTValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Reset not activated
    public static let Disabled = Self(rawValue: 0x0)

    /// Reset the entire RTC domain
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.BDCR {
  public struct RTCENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// RTC clock disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// RTC clock enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.BDCR {
  public struct LSEBYPValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// LSE crystal oscillator not bypassed
    public static let NotBypassed = Self(rawValue: 0x0)

    /// LSE crystal oscillator bypassed with external clock
    public static let Bypassed = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.BDCR {
  public struct LSEONValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// LSE oscillator Off
    public static let Off = Self(rawValue: 0x0)

    /// LSE oscillator On
    public static let On = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.BDCR {
  public struct LSEDRVValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// Low drive capacity
    public static let Low = Self(rawValue: 0x0)

    /// Medium-high drive capacity
    public static let MediumHigh = Self(rawValue: 0x1)

    /// Medium-low drive capacity
    public static let MediumLow = Self(rawValue: 0x2)

    /// High drive capacity
    public static let High = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.BDCR {
  public struct RTCSELValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// No clock
    public static let NoClock = Self(rawValue: 0x0)

    /// LSE oscillator clock used as RTC clock
    public static let LSE = Self(rawValue: 0x1)

    /// LSI oscillator clock used as RTC clock
    public static let LSI = Self(rawValue: 0x2)

    /// HSE oscillator clock divided by a prescaler used as RTC clock
    public static let HSE = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.CSR {
  public struct LSIONValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// LSI oscillator Off
    public static let Off = Self(rawValue: 0x0)

    /// LSI oscillator On
    public static let On = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.SSCGR {
  public struct SSCGENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Spread spectrum modulation disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Spread spectrum modulation enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.SSCGR {
  public struct SPREADSELValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Center spread
    public static let Center = Self(rawValue: 0x0)

    /// Down spread
    public static let Down = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.PLLI2SCFGR {
  public struct PLLI2SPValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// PLL*P=2
    public static let Div2 = Self(rawValue: 0x0)

    /// PLL*P=4
    public static let Div4 = Self(rawValue: 0x1)

    /// PLL*P=6
    public static let Div6 = Self(rawValue: 0x2)

    /// PLL*P=8
    public static let Div8 = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.PLLSAICFGR {
  public struct PLLSAIPValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// PLL*P=2
    public static let Div2 = Self(rawValue: 0x0)

    /// PLL*P=4
    public static let Div4 = Self(rawValue: 0x1)

    /// PLL*P=6
    public static let Div6 = Self(rawValue: 0x2)

    /// PLL*P=8
    public static let Div8 = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR1 {
  public struct PLLI2SDIVQValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 5

    /// PLLI2SDIVQ = /1
    public static let Div1 = Self(rawValue: 0x0)

    /// PLLI2SDIVQ = /2
    public static let Div2 = Self(rawValue: 0x1)

    /// PLLI2SDIVQ = /3
    public static let Div3 = Self(rawValue: 0x2)

    /// PLLI2SDIVQ = /4
    public static let Div4 = Self(rawValue: 0x3)

    /// PLLI2SDIVQ = /5
    public static let Div5 = Self(rawValue: 0x4)

    /// PLLI2SDIVQ = /6
    public static let Div6 = Self(rawValue: 0x5)

    /// PLLI2SDIVQ = /7
    public static let Div7 = Self(rawValue: 0x6)

    /// PLLI2SDIVQ = /8
    public static let Div8 = Self(rawValue: 0x7)

    /// PLLI2SDIVQ = /9
    public static let Div9 = Self(rawValue: 0x8)

    /// PLLI2SDIVQ = /10
    public static let Div10 = Self(rawValue: 0x9)

    /// PLLI2SDIVQ = /11
    public static let Div11 = Self(rawValue: 0xa)

    /// PLLI2SDIVQ = /12
    public static let Div12 = Self(rawValue: 0xb)

    /// PLLI2SDIVQ = /13
    public static let Div13 = Self(rawValue: 0xc)

    /// PLLI2SDIVQ = /14
    public static let Div14 = Self(rawValue: 0xd)

    /// PLLI2SDIVQ = /15
    public static let Div15 = Self(rawValue: 0xe)

    /// PLLI2SDIVQ = /16
    public static let Div16 = Self(rawValue: 0xf)

    /// PLLI2SDIVQ = /17
    public static let Div17 = Self(rawValue: 0x10)

    /// PLLI2SDIVQ = /18
    public static let Div18 = Self(rawValue: 0x11)

    /// PLLI2SDIVQ = /19
    public static let Div19 = Self(rawValue: 0x12)

    /// PLLI2SDIVQ = /20
    public static let Div20 = Self(rawValue: 0x13)

    /// PLLI2SDIVQ = /21
    public static let Div21 = Self(rawValue: 0x14)

    /// PLLI2SDIVQ = /22
    public static let Div22 = Self(rawValue: 0x15)

    /// PLLI2SDIVQ = /23
    public static let Div23 = Self(rawValue: 0x16)

    /// PLLI2SDIVQ = /24
    public static let Div24 = Self(rawValue: 0x17)

    /// PLLI2SDIVQ = /25
    public static let Div25 = Self(rawValue: 0x18)

    /// PLLI2SDIVQ = /26
    public static let Div26 = Self(rawValue: 0x19)

    /// PLLI2SDIVQ = /27
    public static let Div27 = Self(rawValue: 0x1a)

    /// PLLI2SDIVQ = /28
    public static let Div28 = Self(rawValue: 0x1b)

    /// PLLI2SDIVQ = /29
    public static let Div29 = Self(rawValue: 0x1c)

    /// PLLI2SDIVQ = /30
    public static let Div30 = Self(rawValue: 0x1d)

    /// PLLI2SDIVQ = /31
    public static let Div31 = Self(rawValue: 0x1e)

    /// PLLI2SDIVQ = /32
    public static let Div32 = Self(rawValue: 0x1f)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR1 {
  public struct PLLSAIDIVQValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 5

    /// PLLSAIDIVQ = /1
    public static let Div1 = Self(rawValue: 0x0)

    /// PLLSAIDIVQ = /2
    public static let Div2 = Self(rawValue: 0x1)

    /// PLLSAIDIVQ = /3
    public static let Div3 = Self(rawValue: 0x2)

    /// PLLSAIDIVQ = /4
    public static let Div4 = Self(rawValue: 0x3)

    /// PLLSAIDIVQ = /5
    public static let Div5 = Self(rawValue: 0x4)

    /// PLLSAIDIVQ = /6
    public static let Div6 = Self(rawValue: 0x5)

    /// PLLSAIDIVQ = /7
    public static let Div7 = Self(rawValue: 0x6)

    /// PLLSAIDIVQ = /8
    public static let Div8 = Self(rawValue: 0x7)

    /// PLLSAIDIVQ = /9
    public static let Div9 = Self(rawValue: 0x8)

    /// PLLSAIDIVQ = /10
    public static let Div10 = Self(rawValue: 0x9)

    /// PLLSAIDIVQ = /11
    public static let Div11 = Self(rawValue: 0xa)

    /// PLLSAIDIVQ = /12
    public static let Div12 = Self(rawValue: 0xb)

    /// PLLSAIDIVQ = /13
    public static let Div13 = Self(rawValue: 0xc)

    /// PLLSAIDIVQ = /14
    public static let Div14 = Self(rawValue: 0xd)

    /// PLLSAIDIVQ = /15
    public static let Div15 = Self(rawValue: 0xe)

    /// PLLSAIDIVQ = /16
    public static let Div16 = Self(rawValue: 0xf)

    /// PLLSAIDIVQ = /17
    public static let Div17 = Self(rawValue: 0x10)

    /// PLLSAIDIVQ = /18
    public static let Div18 = Self(rawValue: 0x11)

    /// PLLSAIDIVQ = /19
    public static let Div19 = Self(rawValue: 0x12)

    /// PLLSAIDIVQ = /20
    public static let Div20 = Self(rawValue: 0x13)

    /// PLLSAIDIVQ = /21
    public static let Div21 = Self(rawValue: 0x14)

    /// PLLSAIDIVQ = /22
    public static let Div22 = Self(rawValue: 0x15)

    /// PLLSAIDIVQ = /23
    public static let Div23 = Self(rawValue: 0x16)

    /// PLLSAIDIVQ = /24
    public static let Div24 = Self(rawValue: 0x17)

    /// PLLSAIDIVQ = /25
    public static let Div25 = Self(rawValue: 0x18)

    /// PLLSAIDIVQ = /26
    public static let Div26 = Self(rawValue: 0x19)

    /// PLLSAIDIVQ = /27
    public static let Div27 = Self(rawValue: 0x1a)

    /// PLLSAIDIVQ = /28
    public static let Div28 = Self(rawValue: 0x1b)

    /// PLLSAIDIVQ = /29
    public static let Div29 = Self(rawValue: 0x1c)

    /// PLLSAIDIVQ = /30
    public static let Div30 = Self(rawValue: 0x1d)

    /// PLLSAIDIVQ = /31
    public static let Div31 = Self(rawValue: 0x1e)

    /// PLLSAIDIVQ = /32
    public static let Div32 = Self(rawValue: 0x1f)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR1 {
  public struct PLLSAIDIVRValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// PLLSAIDIVR = /2
    public static let Div2 = Self(rawValue: 0x0)

    /// PLLSAIDIVR = /4
    public static let Div4 = Self(rawValue: 0x1)

    /// PLLSAIDIVR = /8
    public static let Div8 = Self(rawValue: 0x2)

    /// PLLSAIDIVR = /16
    public static let Div16 = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR1 {
  public struct SAI1SELValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// SAI1 clock frequency = f(PLLSAI_Q) / PLLSAIDIVQ
    public static let PLLSAI = Self(rawValue: 0x0)

    /// SAI1 clock frequency = f(PLLI2S_Q) / PLLI2SDIVQ
    public static let PLLI2S = Self(rawValue: 0x1)

    /// SAI1 clock frequency = Alternate function input frequency
    public static let AFIF = Self(rawValue: 0x2)

    /// SAI1 clock frequency = HSI or HSE
    public static let HSI_HSE = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR1 {
  public struct SAI2SELValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// SAI2 clock frequency = f(PLLSAI_Q) / PLLSAIDIVQ
    public static let PLLSAI = Self(rawValue: 0x0)

    /// SAI2 clock frequency = f(PLLI2S_Q) / PLLI2SDIVQ
    public static let PLLI2S = Self(rawValue: 0x1)

    /// SAI2 clock frequency = Alternate function input frequency
    public static let AFIF = Self(rawValue: 0x2)

    /// SAI2 clock frequency = HSI or HSE
    public static let HSI_HSE = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR1 {
  public struct TIMPREValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// If the APB prescaler is configured 1, TIMxCLK = PCLKx. Otherwise, TIMxCLK = 2xPCLKx
    public static let Mul1Or2 = Self(rawValue: 0x0)

    /// If the APB prescaler is configured 1, 2 or 4, TIMxCLK = HCLK. Otherwise, TIMxCLK = 4xPCLKx
    public static let Mul1Or4 = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR2 {
  public struct USART1SELValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// APB2 clock (PCLK2) is selected as USART clock
    public static let APB2 = Self(rawValue: 0x0)

    /// System clock is selected as USART clock
    public static let SYSCLK = Self(rawValue: 0x1)

    /// HSI clock is selected as USART clock
    public static let HSI = Self(rawValue: 0x2)

    /// LSE clock is selected as USART clock
    public static let LSE = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR2 {
  public struct USART2SELValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// APB1 clock (PCLK1) is selected as USART clock
    public static let APB1 = Self(rawValue: 0x0)

    /// System clock is selected as USART clock
    public static let SYSCLK = Self(rawValue: 0x1)

    /// HSI clock is selected as USART clock
    public static let HSI = Self(rawValue: 0x2)

    /// LSE clock is selected as USART clock
    public static let LSE = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR2 {
  public struct I2C1SELValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// APB clock selected as I2C clock
    public static let APB = Self(rawValue: 0x0)

    /// System clock selected as I2C clock
    public static let SYSCLK = Self(rawValue: 0x1)

    /// HSI clock selected as I2C clock
    public static let HSI = Self(rawValue: 0x2)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR2 {
  public struct LPTIM1SELValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// APB1 clock (PCLK1) selected as LPTILM1 clock
    public static let APB1 = Self(rawValue: 0x0)

    /// LSI clock is selected as LPTILM1 clock
    public static let LSI = Self(rawValue: 0x1)

    /// HSI clock is selected as LPTILM1 clock
    public static let HSI = Self(rawValue: 0x2)

    /// LSE clock is selected as LPTILM1 clock
    public static let LSE = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR2 {
  public struct CECSELValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// LSE clock is selected as HDMI-CEC clock
    public static let LSE = Self(rawValue: 0x0)

    /// HSI divided by 488 clock is selected as HDMI-CEC clock
    public static let HSI_Div488 = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR2 {
  public struct CK48MSELValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// 48MHz clock from PLL is selected
    public static let PLL = Self(rawValue: 0x0)

    /// 48MHz clock from PLLSAI is selected
    public static let PLLSAI = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension RCC.DCKCFGR2 {
  public struct SDMMC1SELValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// 48 MHz clock is selected as SD clock
    public static let CK48M = Self(rawValue: 0x0)

    /// System clock is selected as SD clock
    public static let SYSCLK = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}
