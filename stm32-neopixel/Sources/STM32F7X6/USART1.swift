// Generated by svd2swift.

import MMIO

/// Universal synchronous asynchronous receiver transmitter
@RegisterBlock
public struct USART1 {
  /// Control register 1
  @RegisterBlock(offset: 0x0)
  public var cr1: Register<CR1>

  /// Control register 2
  @RegisterBlock(offset: 0x4)
  public var cr2: Register<CR2>

  /// Control register 3
  @RegisterBlock(offset: 0x8)
  public var cr3: Register<CR3>

  /// Baud rate register
  @RegisterBlock(offset: 0xc)
  public var brr: Register<BRR>

  /// Guard time and prescaler register
  @RegisterBlock(offset: 0x10)
  public var gtpr: Register<GTPR>

  /// Receiver timeout register
  @RegisterBlock(offset: 0x14)
  public var rtor: Register<RTOR>

  /// Request register
  @RegisterBlock(offset: 0x18)
  public var rqr: Register<RQR>

  /// Interrupt & status register
  @RegisterBlock(offset: 0x1c)
  public var isr: Register<ISR>

  /// Interrupt flag clear register
  @RegisterBlock(offset: 0x20)
  public var icr: Register<ICR>

  /// Receive data register
  @RegisterBlock(offset: 0x24)
  public var rdr: Register<RDR>

  /// Transmit data register
  @RegisterBlock(offset: 0x28)
  public var tdr: Register<TDR>
}

extension USART1 {
  /// Control register 1
  @Register(bitWidth: 32)
  public struct CR1 {
    /// Word length
    @ReadWrite(bits: 28..<29, as: M1Values.self)
    public var m1: M1

    /// End of Block interrupt enable
    @ReadWrite(bits: 27..<28, as: EOBIEValues.self)
    public var eobie: EOBIE

    /// Receiver timeout interrupt enable
    @ReadWrite(bits: 26..<27, as: RTOIEValues.self)
    public var rtoie: RTOIE

    /// Oversampling mode
    @ReadWrite(bits: 15..<16, as: OVER8Values.self)
    public var over8: OVER8

    /// Character match interrupt enable
    @ReadWrite(bits: 14..<15, as: CMIEValues.self)
    public var cmie: CMIE

    /// Mute mode enable
    @ReadWrite(bits: 13..<14, as: MMEValues.self)
    public var mme: MME

    /// Word length
    @ReadWrite(bits: 12..<13, as: M0Values.self)
    public var m0: M0

    /// Receiver wakeup method
    @ReadWrite(bits: 11..<12, as: WAKEValues.self)
    public var wake: WAKE

    /// Parity control enable
    @ReadWrite(bits: 10..<11, as: PCEValues.self)
    public var pce: PCE

    /// Parity selection
    @ReadWrite(bits: 9..<10, as: PSValues.self)
    public var ps: PS

    /// PE interrupt enable
    @ReadWrite(bits: 8..<9, as: PEIEValues.self)
    public var peie: PEIE

    /// interrupt enable
    @ReadWrite(bits: 7..<8, as: TXEIEValues.self)
    public var txeie: TXEIE

    /// Transmission complete interrupt enable
    @ReadWrite(bits: 6..<7, as: TCIEValues.self)
    public var tcie: TCIE

    /// RXNE interrupt enable
    @ReadWrite(bits: 5..<6, as: RXNEIEValues.self)
    public var rxneie: RXNEIE

    /// IDLE interrupt enable
    @ReadWrite(bits: 4..<5, as: IDLEIEValues.self)
    public var idleie: IDLEIE

    /// Transmitter enable
    @ReadWrite(bits: 3..<4, as: TEValues.self)
    public var te: TE

    /// Receiver enable
    @ReadWrite(bits: 2..<3, as: REValues.self)
    public var re: RE

    /// USART enable in Stop mode
    @ReadWrite(bits: 1..<2, as: UESMValues.self)
    public var uesm: UESM

    /// USART enable
    @ReadWrite(bits: 0..<1, as: UEValues.self)
    public var ue: UE

    /// Driver Enable assertion time
    @ReadWrite(bits: 21..<26)
    public var deat: DEAT

    /// Driver Enable de-assertion time
    @ReadWrite(bits: 16..<21)
    public var dedt: DEDT
  }

  /// Control register 2
  @Register(bitWidth: 32)
  public struct CR2 {
    /// Receiver timeout enable
    @ReadWrite(bits: 23..<24, as: RTOENValues.self)
    public var rtoen: RTOEN

    /// Auto baud rate enable
    @ReadWrite(bits: 20..<21, as: ABRENValues.self)
    public var abren: ABREN

    /// Most significant bit first
    @ReadWrite(bits: 19..<20, as: MSBFIRSTValues.self)
    public var msbfirst: MSBFIRST

    /// Binary data inversion
    @ReadWrite(bits: 18..<19, as: DATAINVValues.self)
    public var datainv: DATAINV

    /// TX pin active level inversion
    @ReadWrite(bits: 17..<18, as: TXINVValues.self)
    public var txinv: TXINV

    /// RX pin active level inversion
    @ReadWrite(bits: 16..<17, as: RXINVValues.self)
    public var rxinv: RXINV

    /// Swap TX/RX pins
    @ReadWrite(bits: 15..<16, as: SWAPValues.self)
    public var swap: SWAP

    /// LIN mode enable
    @ReadWrite(bits: 14..<15, as: LINENValues.self)
    public var linen: LINEN

    /// STOP bits
    @ReadWrite(bits: 12..<14, as: STOPValues.self)
    public var stop: STOP

    /// Clock enable
    @ReadWrite(bits: 11..<12, as: CLKENValues.self)
    public var clken: CLKEN

    /// Clock polarity
    @ReadWrite(bits: 10..<11, as: CPOLValues.self)
    public var cpol: CPOL

    /// Clock phase
    @ReadWrite(bits: 9..<10, as: CPHAValues.self)
    public var cpha: CPHA

    /// Last bit clock pulse
    @ReadWrite(bits: 8..<9, as: LBCLValues.self)
    public var lbcl: LBCL

    /// LIN break detection interrupt enable
    @ReadWrite(bits: 6..<7, as: LBDIEValues.self)
    public var lbdie: LBDIE

    /// LIN break detection length
    @ReadWrite(bits: 5..<6, as: LBDLValues.self)
    public var lbdl: LBDL

    /// 7-bit Address Detection/4-bit Address Detection
    @ReadWrite(bits: 4..<5, as: ADDM7Values.self)
    public var addm7: ADDM7

    /// Auto baud rate mode
    @ReadWrite(bits: 21..<23, as: ABRMODValues.self)
    public var abrmod: ABRMOD

    /// Address of the USART node
    @ReadWrite(bits: 24..<32)
    public var add: ADD
  }

  /// Control register 3
  @Register(bitWidth: 32)
  public struct CR3 {
    /// Wakeup from Stop mode interrupt enable
    @ReadWrite(bits: 22..<23, as: WUFIEValues.self)
    public var wufie: WUFIE

    /// Wakeup from Stop mode interrupt flag selection
    @ReadWrite(bits: 20..<22, as: WUSValues.self)
    public var wus: WUS

    /// Smartcard auto-retry count
    @ReadWrite(bits: 17..<20)
    public var scarcnt: SCARCNT

    /// Driver enable polarity selection
    @ReadWrite(bits: 15..<16, as: DEPValues.self)
    public var dep: DEP

    /// Driver enable mode
    @ReadWrite(bits: 14..<15, as: DEMValues.self)
    public var dem: DEM

    /// DMA Disable on Reception Error
    @ReadWrite(bits: 13..<14, as: DDREValues.self)
    public var ddre: DDRE

    /// Overrun Disable
    @ReadWrite(bits: 12..<13, as: OVRDISValues.self)
    public var ovrdis: OVRDIS

    /// One sample bit method enable
    @ReadWrite(bits: 11..<12, as: ONEBITValues.self)
    public var onebit: ONEBIT

    /// CTS interrupt enable
    @ReadWrite(bits: 10..<11, as: CTSIEValues.self)
    public var ctsie: CTSIE

    /// CTS enable
    @ReadWrite(bits: 9..<10, as: CTSEValues.self)
    public var ctse: CTSE

    /// RTS enable
    @ReadWrite(bits: 8..<9, as: RTSEValues.self)
    public var rtse: RTSE

    /// DMA enable transmitter
    @ReadWrite(bits: 7..<8, as: DMATValues.self)
    public var dmat: DMAT

    /// DMA enable receiver
    @ReadWrite(bits: 6..<7, as: DMARValues.self)
    public var dmar: DMAR

    /// Smartcard mode enable
    @ReadWrite(bits: 5..<6, as: SCENValues.self)
    public var scen: SCEN

    /// Smartcard NACK enable
    @ReadWrite(bits: 4..<5, as: NACKValues.self)
    public var nack: NACK

    /// Half-duplex selection
    @ReadWrite(bits: 3..<4, as: HDSELValues.self)
    public var hdsel: HDSEL

    /// Ir low-power
    @ReadWrite(bits: 2..<3, as: IRLPValues.self)
    public var irlp: IRLP

    /// Ir mode enable
    @ReadWrite(bits: 1..<2, as: IRENValues.self)
    public var iren: IREN

    /// Error interrupt enable
    @ReadWrite(bits: 0..<1, as: EIEValues.self)
    public var eie: EIE
  }

  /// Baud rate register
  @Register(bitWidth: 32)
  public struct BRR {
    /// DIV_Mantissa
    @ReadWrite(bits: 0..<16)
    public var brr_field: BRR_FIELD
  }

  /// Guard time and prescaler register
  @Register(bitWidth: 32)
  public struct GTPR {
    /// Guard time value
    @ReadWrite(bits: 8..<16)
    public var gt: GT

    /// Prescaler value
    @ReadWrite(bits: 0..<8)
    public var psc: PSC
  }

  /// Receiver timeout register
  @Register(bitWidth: 32)
  public struct RTOR {
    /// Block Length
    @ReadWrite(bits: 24..<32)
    public var blen: BLEN

    /// Receiver timeout value
    @ReadWrite(bits: 0..<24)
    public var rto: RTO
  }

  /// Request register
  @Register(bitWidth: 32)
  public struct RQR {
    /// Transmit data flush request
    @WriteOnly(bits: 4..<5)
    public var txfrq: TXFRQ

    /// Receive data flush request
    @WriteOnly(bits: 3..<4)
    public var rxfrq: RXFRQ

    /// Mute mode request
    @WriteOnly(bits: 2..<3)
    public var mmrq: MMRQ

    /// Send break request
    @WriteOnly(bits: 1..<2)
    public var sbkrq: SBKRQ

    /// Auto baud rate request
    @WriteOnly(bits: 0..<1)
    public var abrrq: ABRRQ
  }

  /// Interrupt & status register
  @Register(bitWidth: 32)
  public struct ISR {
    /// REACK
    @ReadOnly(bits: 22..<23)
    public var reack: REACK

    /// TEACK
    @ReadOnly(bits: 21..<22)
    public var teack: TEACK

    /// WUF
    @ReadOnly(bits: 20..<21)
    public var wuf: WUF

    /// RWU
    @ReadOnly(bits: 19..<20)
    public var rwu: RWU

    /// SBKF
    @ReadOnly(bits: 18..<19)
    public var sbkf: SBKF

    /// CMF
    @ReadOnly(bits: 17..<18)
    public var cmf: CMF

    /// BUSY
    @ReadOnly(bits: 16..<17)
    public var busy: BUSY

    /// ABRF
    @ReadOnly(bits: 15..<16)
    public var abrf: ABRF

    /// ABRE
    @ReadOnly(bits: 14..<15)
    public var abre: ABRE

    /// EOBF
    @ReadOnly(bits: 12..<13)
    public var eobf: EOBF

    /// RTOF
    @ReadOnly(bits: 11..<12)
    public var rtof: RTOF

    /// CTS
    @ReadOnly(bits: 10..<11)
    public var cts: CTS

    /// CTSIF
    @ReadOnly(bits: 9..<10)
    public var ctsif: CTSIF

    /// LBDF
    @ReadOnly(bits: 8..<9)
    public var lbdf: LBDF

    /// TXE
    @ReadOnly(bits: 7..<8)
    public var txe: TXE

    /// TC
    @ReadOnly(bits: 6..<7)
    public var tc: TC

    /// RXNE
    @ReadOnly(bits: 5..<6)
    public var rxne: RXNE

    /// IDLE
    @ReadOnly(bits: 4..<5)
    public var idle: IDLE

    /// ORE
    @ReadOnly(bits: 3..<4)
    public var ore: ORE

    /// NF
    @ReadOnly(bits: 2..<3)
    public var nf: NF

    /// FE
    @ReadOnly(bits: 1..<2)
    public var fe: FE

    /// PE
    @ReadOnly(bits: 0..<1)
    public var pe: PE
  }

  /// Interrupt flag clear register
  @Register(bitWidth: 32)
  public struct ICR {
    /// Wakeup from Stop mode clear flag
    @WriteOnly(bits: 20..<21)
    public var wucf: WUCF

    /// Character match clear flag
    @WriteOnly(bits: 17..<18)
    public var cmcf: CMCF

    /// End of block clear flag
    @WriteOnly(bits: 12..<13)
    public var eobcf: EOBCF

    /// Receiver timeout clear flag
    @WriteOnly(bits: 11..<12)
    public var rtocf: RTOCF

    /// CTS clear flag
    @WriteOnly(bits: 9..<10)
    public var ctscf: CTSCF

    /// LIN break detection clear flag
    @WriteOnly(bits: 8..<9)
    public var lbdcf: LBDCF

    /// Transmission complete clear flag
    @WriteOnly(bits: 6..<7)
    public var tccf: TCCF

    /// Idle line detected clear flag
    @WriteOnly(bits: 4..<5)
    public var idlecf: IDLECF

    /// Overrun error clear flag
    @WriteOnly(bits: 3..<4)
    public var orecf: ORECF

    /// Noise detected clear flag
    @WriteOnly(bits: 2..<3)
    public var ncf: NCF

    /// Framing error clear flag
    @WriteOnly(bits: 1..<2)
    public var fecf: FECF

    /// Parity error clear flag
    @WriteOnly(bits: 0..<1)
    public var pecf: PECF
  }

  /// Receive data register
  @Register(bitWidth: 32)
  public struct RDR {
    /// Receive data value
    @ReadOnly(bits: 0..<9)
    public var rdr_field: RDR_FIELD
  }

  /// Transmit data register
  @Register(bitWidth: 32)
  public struct TDR {
    /// Transmit data value
    @ReadWrite(bits: 0..<9)
    public var tdr_field: TDR_FIELD
  }
}

extension USART1.CR1 {
  public struct M1Values: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Use M0 to set the data bits
    public static let M0 = Self(rawValue: 0x0)

    /// 1 start bit, 7 data bits, n stop bits
    public static let Bit7 = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct EOBIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt is inhibited
    public static let Disabled = Self(rawValue: 0x0)

    /// A USART interrupt is generated when the EOBF flag is set in the ISR register
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct RTOIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt is inhibited
    public static let Disabled = Self(rawValue: 0x0)

    /// An USART interrupt is generated when the RTOF bit is set in the ISR register
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct OVER8Values: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Oversampling by 16
    public static let Oversampling16 = Self(rawValue: 0x0)

    /// Oversampling by 8
    public static let Oversampling8 = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct CMIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Interrupt is generated when the CMF bit is set in the ISR register
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct MMEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Receiver in active mode permanently
    public static let Disabled = Self(rawValue: 0x0)

    /// Receiver can switch between mute mode and active mode
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct M0Values: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// 1 start bit, 8 data bits, n stop bits
    public static let Bit8 = Self(rawValue: 0x0)

    /// 1 start bit, 9 data bits, n stop bits
    public static let Bit9 = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct WAKEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Idle line
    public static let Idle = Self(rawValue: 0x0)

    /// Address mask
    public static let Address = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct PCEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Parity control disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Parity control enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct PSValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Even parity
    public static let Even = Self(rawValue: 0x0)

    /// Odd parity
    public static let Odd = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct PEIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Interrupt is generated whenever PE=1 in the ISR register
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct TXEIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Interrupt is generated whenever TXE=1 in the ISR register
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct TCIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Interrupt is generated whenever TC=1 in the ISR register
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct RXNEIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Interrupt is generated whenever ORE=1 or RXNE=1 in the ISR register
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct IDLEIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Interrupt is generated whenever IDLE=1 in the ISR register
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct TEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Transmitter is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Transmitter is enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct REValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Receiver is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Receiver is enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct UESMValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// USART not able to wake up the MCU from Stop mode
    public static let Disabled = Self(rawValue: 0x0)

    /// USART able to wake up the MCU from Stop mode
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR1 {
  public struct UEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// UART is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// UART is enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct RTOENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Receiver timeout feature disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Receiver timeout feature enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct ABRENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Auto baud rate detection is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Auto baud rate detection is enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct MSBFIRSTValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// data is transmitted/received with data bit 0 first, following the start bit
    public static let LSB = Self(rawValue: 0x0)

    /// data is transmitted/received with MSB (bit 7/8/9) first, following the start bit
    public static let MSB = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct DATAINVValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Logical data from the data register are send/received in positive/direct logic
    public static let Positive = Self(rawValue: 0x0)

    /// Logical data from the data register are send/received in negative/inverse logic
    public static let Negative = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct TXINVValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// TX pin signal works using the standard logic levels
    public static let Standard = Self(rawValue: 0x0)

    /// TX pin signal values are inverted
    public static let Inverted = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct RXINVValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// RX pin signal works using the standard logic levels
    public static let Standard = Self(rawValue: 0x0)

    /// RX pin signal values are inverted
    public static let Inverted = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct SWAPValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// TX/RX pins are used as defined in standard pinout
    public static let Standard = Self(rawValue: 0x0)

    /// The TX and RX pins functions are swapped
    public static let Swapped = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct LINENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// LIN mode disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// LIN mode enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct STOPValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// 1 stop bit
    public static let Stop1 = Self(rawValue: 0x0)

    /// 0.5 stop bit
    public static let Stop0p5 = Self(rawValue: 0x1)

    /// 2 stop bit
    public static let Stop2 = Self(rawValue: 0x2)

    /// 1.5 stop bit
    public static let Stop1p5 = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct CLKENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// CK pin disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// CK pin enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct CPOLValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Steady low value on CK pin outside transmission window
    public static let Low = Self(rawValue: 0x0)

    /// Steady high value on CK pin outside transmission window
    public static let High = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct CPHAValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// The first clock transition is the first data capture edge
    public static let First = Self(rawValue: 0x0)

    /// The second clock transition is the first data capture edge
    public static let Second = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct LBCLValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// The clock pulse of the last data bit is not output to the CK pin
    public static let NotOutput = Self(rawValue: 0x0)

    /// The clock pulse of the last data bit is output to the CK pin
    public static let Output = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct LBDIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt is inhibited
    public static let Disabled = Self(rawValue: 0x0)

    /// An interrupt is generated whenever LBDF=1 in the ISR register
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct LBDLValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// 10-bit break detection
    public static let Bit10 = Self(rawValue: 0x0)

    /// 11-bit break detection
    public static let Bit11 = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct ADDM7Values: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// 4-bit address detection
    public static let Bit4 = Self(rawValue: 0x0)

    /// 7-bit address detection
    public static let Bit7 = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR2 {
  public struct ABRMODValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// Measurement of the start bit is used to detect the baud rate
    public static let Start = Self(rawValue: 0x0)

    /// Falling edge to falling edge measurement
    public static let Edge = Self(rawValue: 0x1)

    /// 0x7F frame detection
    public static let Frame7F = Self(rawValue: 0x2)

    /// 0x55 frame detection
    public static let Frame55 = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct WUFIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt is inhibited
    public static let Disabled = Self(rawValue: 0x0)

    /// An USART interrupt is generated whenever WUF=1 in the ISR register
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct WUSValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 2

    /// WUF active on address match
    public static let Address = Self(rawValue: 0x0)

    /// WuF active on Start bit detection
    public static let Start = Self(rawValue: 0x2)

    /// WUF active on RXNE
    public static let RXNE = Self(rawValue: 0x3)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct DEPValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// DE signal is active high
    public static let High = Self(rawValue: 0x0)

    /// DE signal is active low
    public static let Low = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct DEMValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// DE function is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// The DE signal is output on the RTS pin
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct DDREValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// DMA is not disabled in case of reception error
    public static let NotDisabled = Self(rawValue: 0x0)

    /// DMA is disabled following a reception error
    public static let Disabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct OVRDISValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Overrun Error Flag, ORE, is set when received data is not read before receiving new data
    public static let Enabled = Self(rawValue: 0x0)

    /// Overrun functionality is disabled. If new data is received while the RXNE flag is still set the ORE flag is not set and the new received data overwrites the previous content of the RDR register
    public static let Disabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct ONEBITValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Three sample bit method
    public static let Sample3 = Self(rawValue: 0x0)

    /// One sample bit method
    public static let Sample1 = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct CTSIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt is inhibited
    public static let Disabled = Self(rawValue: 0x0)

    /// An interrupt is generated whenever CTSIF=1 in the ISR register
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct CTSEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// CTS hardware flow control disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// CTS mode enabled, data is only transmitted when the CTS input is asserted
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct RTSEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// RTS hardware flow control disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// RTS output enabled, data is only requested when there is space in the receive buffer
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct DMATValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// DMA mode is disabled for transmission
    public static let Disabled = Self(rawValue: 0x0)

    /// DMA mode is enabled for transmission
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct DMARValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// DMA mode is disabled for reception
    public static let Disabled = Self(rawValue: 0x0)

    /// DMA mode is enabled for reception
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct SCENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Smartcard Mode disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// Smartcard Mode enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct NACKValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// NACK transmission in case of parity error is disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// NACK transmission during parity error is enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct HDSELValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Half duplex mode is not selected
    public static let NotSelected = Self(rawValue: 0x0)

    /// Half duplex mode is selected
    public static let Selected = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct IRLPValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Normal mode
    public static let Normal = Self(rawValue: 0x0)

    /// Low-power mode
    public static let LowPower = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct IRENValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// IrDA disabled
    public static let Disabled = Self(rawValue: 0x0)

    /// IrDA enabled
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}

extension USART1.CR3 {
  public struct EIEValues: BitFieldProjectable, RawRepresentable {
    public static let bitWidth = 1

    /// Interrupt is inhibited
    public static let Disabled = Self(rawValue: 0x0)

    /// An interrupt is generated when FE=1 or ORE=1 or NF=1 in the ISR register
    public static let Enabled = Self(rawValue: 0x1)

    public var rawValue: UInt8

    @inlinable @inline(__always)
    public init(rawValue: Self.RawValue) {
      self.rawValue = rawValue
    }
  }
}
